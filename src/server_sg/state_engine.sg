struct RoomRuntimeState {
    session_id: i64,
    capacity: i64,
    player_count: i64,
    online_human_count: i64,
    started: bool,
    outdated: bool,
    owner_conn_id: i64,
    lua_ref_count: i64,
}

struct RoomTransitionResult {
    state: RoomRuntimeState,
    applied: bool,
    reason_code: i64,
}

struct PlayerRuntimeState {
    conn_id: i64,
    state_code: i64,
    ttl: i64,
    inside_game: bool,
    is_died: bool,
}

struct PlayerTransitionResult {
    state: PlayerRuntimeState,
    applied: bool,
    reason_code: i64,
}

struct TaskRuntimeState {
    next_task_id: i64,
    active_task_count: i64,
    pending_reply_count: i64,
}

struct TaskTransitionResult {
    state: TaskRuntimeState,
    applied: bool,
    reason_code: i64,
    issued_task_id: i64,
}

def new_room_runtime_state(capacity: i64, owner_conn_id: i64, next_session_id: i64) -> RoomRuntimeState
requires capacity > 0 && owner_conn_id >= 0 && next_session_id >= 0
ensures result.capacity == capacity && result.player_count == 0 && result.started == false && result.outdated == false
{
    RoomRuntimeState {
        session_id: next_session_id,
        capacity: capacity,
        player_count: 0,
        online_human_count: 0,
        started: false,
        outdated: false,
        owner_conn_id: owner_conn_id,
        lua_ref_count: 0,
    }
}

def apply_room_join(state: RoomRuntimeState, joiner_online: bool) -> RoomTransitionResult
requires state.capacity > 0 && state.player_count >= 0 && state.online_human_count >= 0
{
    if !joiner_online {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7101,
        }
    } else if state.started {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7102,
        }
    } else if state.outdated {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7103,
        }
    } else if state.player_count >= state.capacity {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7104,
        }
    } else {
        RoomTransitionResult {
            state: RoomRuntimeState {
                session_id: state.session_id,
                capacity: state.capacity,
                player_count: state.player_count + 1,
                online_human_count: state.online_human_count + 1,
                started: state.started,
                outdated: state.outdated,
                owner_conn_id: state.owner_conn_id,
                lua_ref_count: state.lua_ref_count,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_room_leave(state: RoomRuntimeState, leaving_online_human: bool) -> RoomTransitionResult
requires state.capacity > 0 && state.player_count >= 0 && state.online_human_count >= 0
{
    if state.player_count == 0 {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7105,
        }
    } else {
        let next_player_count = state.player_count - 1;
        let next_online_human_count = if leaving_online_human && state.online_human_count > 0 {
            state.online_human_count - 1
        } else {
            state.online_human_count
        };
        let next_owner_conn_id = if next_player_count == 0 {
            0
        } else {
            state.owner_conn_id
        };
        let next_started = if next_player_count == 0 {
            false
        } else {
            state.started
        };
        RoomTransitionResult {
            state: RoomRuntimeState {
                session_id: state.session_id,
                capacity: state.capacity,
                player_count: next_player_count,
                online_human_count: next_online_human_count,
                started: next_started,
                outdated: state.outdated,
                owner_conn_id: next_owner_conn_id,
                lua_ref_count: state.lua_ref_count,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_room_start(state: RoomRuntimeState) -> RoomTransitionResult
requires state.capacity > 0 && state.player_count >= 0
{
    if state.started {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7106,
        }
    } else if state.outdated {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7107,
        }
    } else if state.player_count != state.capacity {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7108,
        }
    } else {
        RoomTransitionResult {
            state: RoomRuntimeState {
                session_id: state.session_id,
                capacity: state.capacity,
                player_count: state.player_count,
                online_human_count: state.online_human_count,
                started: true,
                outdated: state.outdated,
                owner_conn_id: state.owner_conn_id,
                lua_ref_count: state.lua_ref_count,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_room_mark_outdated(state: RoomRuntimeState, md5_matches_server: bool) -> RoomTransitionResult
{
    if md5_matches_server {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7109,
        }
    } else if state.outdated {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7110,
        }
    } else {
        RoomTransitionResult {
            state: RoomRuntimeState {
                session_id: state.session_id,
                capacity: state.capacity,
                player_count: state.player_count,
                online_human_count: state.online_human_count,
                started: state.started,
                outdated: true,
                owner_conn_id: state.owner_conn_id,
                lua_ref_count: state.lua_ref_count,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_room_set_lua_ref_count(state: RoomRuntimeState, lua_ref_count: i64) -> RoomTransitionResult
requires lua_ref_count >= 0
{
    if state.lua_ref_count == lua_ref_count {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7111,
        }
    } else {
        RoomTransitionResult {
            state: RoomRuntimeState {
                session_id: state.session_id,
                capacity: state.capacity,
                player_count: state.player_count,
                online_human_count: state.online_human_count,
                started: state.started,
                outdated: state.outdated,
                owner_conn_id: state.owner_conn_id,
                lua_ref_count: lua_ref_count,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def should_collect_room_runtime(state: RoomRuntimeState) -> bool
{
    let abandoned = state.player_count == 0 || state.online_human_count == 0;
    abandoned && state.lua_ref_count == 0
}

def can_dispatch_room_rpc(state: RoomRuntimeState) -> bool
{
    state.started && !state.outdated && state.online_human_count > 0
}

def new_player_runtime_state(conn_id: i64, initial_ttl: i64, initial_state_code: i64) -> PlayerRuntimeState
requires conn_id >= 0 && initial_ttl >= 0 && initial_state_code >= 0 && initial_state_code <= 6
{
    PlayerRuntimeState {
        conn_id: conn_id,
        state_code: initial_state_code,
        ttl: initial_ttl,
        inside_game: false,
        is_died: false,
    }
}

def apply_player_heartbeat(state: PlayerRuntimeState, max_ttl: i64) -> PlayerTransitionResult
requires max_ttl >= 0
{
    if max_ttl == 0 {
        PlayerTransitionResult {
            state: state,
            applied: false,
            reason_code: 7201,
        }
    } else {
        let next_state_code = if state.state_code == 6 {
            1
        } else {
            state.state_code
        };
        PlayerTransitionResult {
            state: PlayerRuntimeState {
                conn_id: state.conn_id,
                state_code: next_state_code,
                ttl: max_ttl,
                inside_game: state.inside_game,
                is_died: state.is_died,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_player_disconnect(state: PlayerRuntimeState) -> PlayerTransitionResult
{
    if state.state_code == 6 {
        PlayerTransitionResult {
            state: state,
            applied: false,
            reason_code: 7202,
        }
    } else {
        let mark_run = state.inside_game && !state.is_died;
        let next_state_code = if mark_run {
            5
        } else {
            6
        };
        PlayerTransitionResult {
            state: PlayerRuntimeState {
                conn_id: state.conn_id,
                state_code: next_state_code,
                ttl: 0,
                inside_game: mark_run,
                is_died: state.is_died,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_player_set_dead(state: PlayerRuntimeState, is_died: bool) -> PlayerTransitionResult
{
    if state.is_died == is_died {
        PlayerTransitionResult {
            state: state,
            applied: false,
            reason_code: 7203,
        }
    } else {
        PlayerTransitionResult {
            state: PlayerRuntimeState {
                conn_id: state.conn_id,
                state_code: state.state_code,
                ttl: state.ttl,
                inside_game: state.inside_game,
                is_died: is_died,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_player_enter_game(state: PlayerRuntimeState) -> PlayerTransitionResult
{
    if state.state_code == 6 {
        PlayerTransitionResult {
            state: state,
            applied: false,
            reason_code: 7204,
        }
    } else if state.inside_game {
        PlayerTransitionResult {
            state: state,
            applied: false,
            reason_code: 7205,
        }
    } else {
        PlayerTransitionResult {
            state: PlayerRuntimeState {
                conn_id: state.conn_id,
                state_code: state.state_code,
                ttl: state.ttl,
                inside_game: true,
                is_died: state.is_died,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_player_ttl_tick(state: PlayerRuntimeState) -> PlayerTransitionResult
{
    if state.ttl == 0 {
        PlayerTransitionResult {
            state: state,
            applied: false,
            reason_code: 7206,
        }
    } else {
        let next_ttl = state.ttl - 1;
        let next_state_code = if next_ttl == 0 {
            6
        } else {
            state.state_code
        };
        let next_inside_game = if next_ttl == 0 {
            false
        } else {
            state.inside_game
        };
        PlayerTransitionResult {
            state: PlayerRuntimeState {
                conn_id: state.conn_id,
                state_code: next_state_code,
                ttl: next_ttl,
                inside_game: next_inside_game,
                is_died: state.is_died,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def can_player_accept_request(state: PlayerRuntimeState) -> bool
{
    let active_state = state.state_code == 1 || state.state_code == 2 || state.state_code == 3;
    active_state && state.ttl > 0
}

def new_task_runtime_state(start_task_id: i64) -> TaskRuntimeState
requires start_task_id <= -1
{
    TaskRuntimeState {
        next_task_id: start_task_id,
        active_task_count: 0,
        pending_reply_count: 0,
    }
}

def apply_issue_task(state: TaskRuntimeState, conn_id: i64, track_request_id: bool) -> TaskTransitionResult
{
    if conn_id <= 0 {
        TaskTransitionResult {
            state: state,
            applied: false,
            reason_code: 7301,
            issued_task_id: -1,
        }
    } else {
        let next_pending_reply_count = if track_request_id {
            state.pending_reply_count + 1
        } else {
            state.pending_reply_count
        };
        TaskTransitionResult {
            state: TaskRuntimeState {
                next_task_id: state.next_task_id - 1,
                active_task_count: state.active_task_count + 1,
                pending_reply_count: next_pending_reply_count,
            },
            applied: true,
            reason_code: 0,
            issued_task_id: state.next_task_id,
        }
    }
}

def apply_finish_task(state: TaskRuntimeState, had_pending_reply: bool) -> TaskTransitionResult
{
    if state.active_task_count == 0 {
        TaskTransitionResult {
            state: state,
            applied: false,
            reason_code: 7302,
            issued_task_id: -1,
        }
    } else {
        let next_pending_reply_count = if had_pending_reply && state.pending_reply_count > 0 {
            state.pending_reply_count - 1
        } else {
            state.pending_reply_count
        };
        TaskTransitionResult {
            state: TaskRuntimeState {
                next_task_id: state.next_task_id,
                active_task_count: state.active_task_count - 1,
                pending_reply_count: next_pending_reply_count,
            },
            applied: true,
            reason_code: 0,
            issued_task_id: -1,
        }
    }
}

def apply_abort_all_tasks(state: TaskRuntimeState) -> TaskTransitionResult
{
    if state.active_task_count == 0 && state.pending_reply_count == 0 {
        TaskTransitionResult {
            state: state,
            applied: false,
            reason_code: 7303,
            issued_task_id: -1,
        }
    } else {
        TaskTransitionResult {
            state: TaskRuntimeState {
                next_task_id: state.next_task_id,
                active_task_count: 0,
                pending_reply_count: 0,
            },
            applied: true,
            reason_code: 0,
            issued_task_id: -1,
        }
    }
}

def can_gc_user_task_bucket(state: TaskRuntimeState) -> bool
{
    state.active_task_count == 0
}

def can_lookup_reply_mapping(state: TaskRuntimeState) -> bool
{
    state.pending_reply_count > 0
}

struct RuntimeEngineState {
    room: RoomRuntimeState,
    player: PlayerRuntimeState,
    task: TaskRuntimeState,
}

struct RuntimeEngineResult {
    state: RuntimeEngineState,
    applied: bool,
    reason_code: i64,
    event_code: i64,
}

def bool_from_flag(flag: i64) -> bool
{
    flag != 0
}

def normalize_non_negative_i64(value: i64) -> i64
{
    if value < 0 {
        0
    } else {
        value
    }
}

def new_runtime_engine_state(
    room_capacity: i64,
    owner_conn_id: i64,
    first_session_id: i64,
    conn_id: i64,
    initial_ttl: i64,
    initial_state_code: i64,
    start_task_id: i64,
) -> RuntimeEngineState
{
    RuntimeEngineState {
        room: new_room_runtime_state(room_capacity, owner_conn_id, first_session_id),
        player: new_player_runtime_state(conn_id, initial_ttl, initial_state_code),
        task: new_task_runtime_state(start_task_id),
    }
}

def apply_runtime_event(state: RuntimeEngineState, event_code: i64, arg1: i64, arg2: i64) -> RuntimeEngineResult
{
    if event_code == 1 {
        let room_result = apply_room_join(state.room, bool_from_flag(arg1));
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: room_result.state,
                player: state.player,
                task: state.task,
            },
            applied: room_result.applied,
            reason_code: room_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 2 {
        let room_result = apply_room_leave(state.room, bool_from_flag(arg1));
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: room_result.state,
                player: state.player,
                task: state.task,
            },
            applied: room_result.applied,
            reason_code: room_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 3 {
        let room_result = apply_room_start(state.room);
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: room_result.state,
                player: state.player,
                task: state.task,
            },
            applied: room_result.applied,
            reason_code: room_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 4 {
        let room_result = apply_room_mark_outdated(state.room, bool_from_flag(arg1));
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: room_result.state,
                player: state.player,
                task: state.task,
            },
            applied: room_result.applied,
            reason_code: room_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 5 {
        let player_result = apply_player_heartbeat(state.player, normalize_non_negative_i64(arg1));
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: state.room,
                player: player_result.state,
                task: state.task,
            },
            applied: player_result.applied,
            reason_code: player_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 6 {
        let player_result = apply_player_disconnect(state.player);
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: state.room,
                player: player_result.state,
                task: state.task,
            },
            applied: player_result.applied,
            reason_code: player_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 7 {
        let task_result = apply_issue_task(state.task, arg1, bool_from_flag(arg2));
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: state.room,
                player: state.player,
                task: task_result.state,
            },
            applied: task_result.applied,
            reason_code: task_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 8 {
        let task_result = apply_finish_task(state.task, bool_from_flag(arg1));
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: state.room,
                player: state.player,
                task: task_result.state,
            },
            applied: task_result.applied,
            reason_code: task_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 9 {
        let task_result = apply_abort_all_tasks(state.task);
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: state.room,
                player: state.player,
                task: task_result.state,
            },
            applied: task_result.applied,
            reason_code: task_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 10 {
        let player_result = apply_player_enter_game(state.player);
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: state.room,
                player: player_result.state,
                task: state.task,
            },
            applied: player_result.applied,
            reason_code: player_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 11 {
        let player_result = apply_player_set_dead(state.player, bool_from_flag(arg1));
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: state.room,
                player: player_result.state,
                task: state.task,
            },
            applied: player_result.applied,
            reason_code: player_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 12 {
        let room_result = apply_room_set_lua_ref_count(state.room, normalize_non_negative_i64(arg1));
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: room_result.state,
                player: state.player,
                task: state.task,
            },
            applied: room_result.applied,
            reason_code: room_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 13 {
        let player_result = apply_player_ttl_tick(state.player);
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: state.room,
                player: player_result.state,
                task: state.task,
            },
            applied: player_result.applied,
            reason_code: player_result.reason_code,
            event_code: event_code,
        }
    } else {
        RuntimeEngineResult {
            state: state,
            applied: false,
            reason_code: 7999,
            event_code: event_code,
        }
    }
}

def can_runtime_dispatch_rpc(state: RuntimeEngineState) -> bool
{
    can_dispatch_room_rpc(state.room) && can_player_accept_request(state.player)
}

def should_runtime_collect_gc(state: RuntimeEngineState) -> bool
{
    should_collect_room_runtime(state.room) && can_gc_user_task_bucket(state.task)
}

def should_runtime_emit_heartbeat_warning(state: RuntimeEngineState) -> bool
{
    state.player.state_code != 6 && state.player.ttl <= 1
}

struct RuntimeIoOp {
    kind: i64,
    subject_id: i64,
    value_a: i64,
    value_b: i64,
    immediate: bool,
}

struct RuntimeIoDispatch {
    has_op: bool,
    op: RuntimeIoOp,
    reason_code: i64,
}

def runtime_io_kind_none() -> i64
ensures result == 0
{
    0
}

def runtime_io_kind_room_changed() -> i64
ensures result == 1001
{
    1001
}

def runtime_io_kind_room_started() -> i64
ensures result == 1002
{
    1002
}

def runtime_io_kind_heartbeat_ack() -> i64
ensures result == 1003
{
    1003
}

def runtime_io_kind_player_disconnected() -> i64
ensures result == 1004
{
    1004
}

def runtime_io_kind_task_issued() -> i64
ensures result == 1101
{
    1101
}

def runtime_io_kind_task_finished() -> i64
ensures result == 1102
{
    1102
}

def runtime_io_kind_gc_suggested() -> i64
ensures result == 1201
{
    1201
}

def empty_runtime_io_op() -> RuntimeIoOp
{
    RuntimeIoOp {
        kind: runtime_io_kind_none(),
        subject_id: 0,
        value_a: 0,
        value_b: 0,
        immediate: false,
    }
}

def build_runtime_io_dispatch(previous_state: RuntimeEngineState, event_result: RuntimeEngineResult) -> RuntimeIoDispatch
{
    let state = event_result.state;
    if !event_result.applied {
        RuntimeIoDispatch {
            has_op: false,
            op: empty_runtime_io_op(),
            reason_code: 7401,
        }
    } else if event_result.event_code == 1 || event_result.event_code == 2 {
        RuntimeIoDispatch {
            has_op: true,
            op: RuntimeIoOp {
                kind: runtime_io_kind_room_changed(),
                subject_id: state.room.session_id,
                value_a: state.room.player_count,
                value_b: state.room.online_human_count,
                immediate: true,
            },
            reason_code: 0,
        }
    } else if event_result.event_code == 3 {
        RuntimeIoDispatch {
            has_op: true,
            op: RuntimeIoOp {
                kind: runtime_io_kind_room_started(),
                subject_id: state.room.session_id,
                value_a: state.room.player_count,
                value_b: state.room.capacity,
                immediate: true,
            },
            reason_code: 0,
        }
    } else if event_result.event_code == 5 {
        RuntimeIoDispatch {
            has_op: true,
            op: RuntimeIoOp {
                kind: runtime_io_kind_heartbeat_ack(),
                subject_id: state.player.conn_id,
                value_a: state.player.ttl,
                value_b: 0,
                immediate: true,
            },
            reason_code: 0,
        }
    } else if event_result.event_code == 6 {
        RuntimeIoDispatch {
            has_op: true,
            op: RuntimeIoOp {
                kind: runtime_io_kind_player_disconnected(),
                subject_id: state.player.conn_id,
                value_a: state.player.state_code,
                value_b: state.player.ttl,
                immediate: true,
            },
            reason_code: 0,
        }
    } else if event_result.event_code == 7 {
        RuntimeIoDispatch {
            has_op: true,
            op: RuntimeIoOp {
                kind: runtime_io_kind_task_issued(),
                subject_id: previous_state.task.next_task_id,
                value_a: state.task.active_task_count,
                value_b: state.task.pending_reply_count,
                immediate: false,
            },
            reason_code: 0,
        }
    } else if event_result.event_code == 8 || event_result.event_code == 9 {
        RuntimeIoDispatch {
            has_op: true,
            op: RuntimeIoOp {
                kind: runtime_io_kind_task_finished(),
                subject_id: state.player.conn_id,
                value_a: state.task.active_task_count,
                value_b: state.task.pending_reply_count,
                immediate: false,
            },
            reason_code: 0,
        }
    } else if should_runtime_collect_gc(state) {
        RuntimeIoDispatch {
            has_op: true,
            op: RuntimeIoOp {
                kind: runtime_io_kind_gc_suggested(),
                subject_id: state.room.session_id,
                value_a: state.task.active_task_count,
                value_b: state.room.lua_ref_count,
                immediate: false,
            },
            reason_code: 0,
        }
    } else {
        RuntimeIoDispatch {
            has_op: false,
            op: empty_runtime_io_op(),
            reason_code: 7402,
        }
    }
}

def should_runtime_emit_io(dispatch: RuntimeIoDispatch) -> bool
{
    dispatch.has_op && dispatch.op.kind != runtime_io_kind_none()
}

struct RuntimeHostState {
    outbound_message_count: i64,
    db_write_count: i64,
    gc_sweep_count: i64,
    warning_count: i64,
    last_subject_id: i64,
    last_io_kind: i64,
}

struct RuntimeHostResult {
    state: RuntimeHostState,
    applied: bool,
    reason_code: i64,
}

struct RuntimeStepResult {
    engine_result: RuntimeEngineResult,
    io_dispatch: RuntimeIoDispatch,
    host_result: RuntimeHostResult,
}

struct RuntimeEvent {
    code: i64,
    arg1: i64,
    arg2: i64,
}

def runtime_event_room_join() -> i64
ensures result == 1
{
    1
}

def runtime_event_room_leave() -> i64
ensures result == 2
{
    2
}

def runtime_event_room_start() -> i64
ensures result == 3
{
    3
}

def runtime_event_room_mark_outdated() -> i64
ensures result == 4
{
    4
}

def runtime_event_player_heartbeat() -> i64
ensures result == 5
{
    5
}

def runtime_event_player_disconnect() -> i64
ensures result == 6
{
    6
}

def runtime_event_task_issue() -> i64
ensures result == 7
{
    7
}

def runtime_event_task_finish() -> i64
ensures result == 8
{
    8
}

def runtime_event_task_abort_all() -> i64
ensures result == 9
{
    9
}

def runtime_event_player_enter_game() -> i64
ensures result == 10
{
    10
}

def runtime_event_player_set_dead() -> i64
ensures result == 11
{
    11
}

def runtime_event_room_set_lua_ref() -> i64
ensures result == 12
{
    12
}

def runtime_event_player_ttl_tick() -> i64
ensures result == 13
{
    13
}

def is_runtime_event_known(event_code: i64) -> bool
{
    event_code >= 1 && event_code <= 13
}

def make_runtime_event(code: i64, arg1: i64, arg2: i64) -> RuntimeEvent
{
    RuntimeEvent {
        code: code,
        arg1: arg1,
        arg2: arg2,
    }
}

def new_runtime_host_state() -> RuntimeHostState
{
    RuntimeHostState {
        outbound_message_count: 0,
        db_write_count: 0,
        gc_sweep_count: 0,
        warning_count: 0,
        last_subject_id: 0,
        last_io_kind: runtime_io_kind_none(),
    }
}

def apply_runtime_io_dispatch_to_host(host: RuntimeHostState, dispatch: RuntimeIoDispatch) -> RuntimeHostResult
{
    if !should_runtime_emit_io(dispatch) {
        RuntimeHostResult {
            state: host,
            applied: false,
            reason_code: 7501,
        }
    } else {
        let op = dispatch.op;
        let next_outbound = if op.kind == runtime_io_kind_room_changed()
            || op.kind == runtime_io_kind_room_started()
            || op.kind == runtime_io_kind_heartbeat_ack()
            || op.kind == runtime_io_kind_player_disconnected()
        {
            host.outbound_message_count + 1
        } else {
            host.outbound_message_count
        };

        let next_db_write = if op.kind == runtime_io_kind_task_issued()
            || op.kind == runtime_io_kind_task_finished()
        {
            host.db_write_count + 1
        } else {
            host.db_write_count
        };

        let next_gc_sweep = if op.kind == runtime_io_kind_gc_suggested() {
            host.gc_sweep_count + 1
        } else {
            host.gc_sweep_count
        };

        RuntimeHostResult {
            state: RuntimeHostState {
                outbound_message_count: next_outbound,
                db_write_count: next_db_write,
                gc_sweep_count: next_gc_sweep,
                warning_count: host.warning_count,
                last_subject_id: op.subject_id,
                last_io_kind: op.kind,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_runtime_warning_tick(host: RuntimeHostState, should_warn: bool) -> RuntimeHostResult
{
    if !should_warn {
        RuntimeHostResult {
            state: host,
            applied: false,
            reason_code: 7502,
        }
    } else {
        RuntimeHostResult {
            state: RuntimeHostState {
                outbound_message_count: host.outbound_message_count,
                db_write_count: host.db_write_count,
                gc_sweep_count: host.gc_sweep_count,
                warning_count: host.warning_count + 1,
                last_subject_id: host.last_subject_id,
                last_io_kind: host.last_io_kind,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_runtime_step(
    runtime_state: RuntimeEngineState,
    host_state: RuntimeHostState,
    event_code: i64,
    arg1: i64,
    arg2: i64,
) -> RuntimeStepResult
{
    let engine_result = apply_runtime_event(runtime_state, event_code, arg1, arg2);
    let io_dispatch = build_runtime_io_dispatch(runtime_state, engine_result);
    let io_result = apply_runtime_io_dispatch_to_host(host_state, io_dispatch);
    let warning_result = apply_runtime_warning_tick(io_result.state, should_runtime_emit_heartbeat_warning(engine_result.state));
    let final_host_result = if warning_result.applied {
        warning_result
    } else {
        io_result
    };

    RuntimeStepResult {
        engine_result: engine_result,
        io_dispatch: io_dispatch,
        host_result: final_host_result,
    }
}

def should_runtime_shutdown(host_state: RuntimeHostState) -> bool
{
    host_state.warning_count >= 3
}

def apply_runtime_event_record(state: RuntimeEngineState, event: RuntimeEvent) -> RuntimeEngineResult
{
    if !is_runtime_event_known(event.code) {
        RuntimeEngineResult {
            state: state,
            applied: false,
            reason_code: 7601,
            event_code: event.code,
        }
    } else {
        apply_runtime_event(state, event.code, event.arg1, event.arg2)
    }
}

def apply_runtime_step_record(
    runtime_state: RuntimeEngineState,
    host_state: RuntimeHostState,
    event: RuntimeEvent,
) -> RuntimeStepResult
{
    if !is_runtime_event_known(event.code) {
        let unknown_engine = RuntimeEngineResult {
            state: runtime_state,
            applied: false,
            reason_code: 7601,
            event_code: event.code,
        };
        let io_dispatch = build_runtime_io_dispatch(runtime_state, unknown_engine);
        let io_result = apply_runtime_io_dispatch_to_host(host_state, io_dispatch);
        RuntimeStepResult {
            engine_result: unknown_engine,
            io_dispatch: io_dispatch,
            host_result: io_result,
        }
    } else {
        apply_runtime_step(runtime_state, host_state, event.code, event.arg1, event.arg2)
    }
}

struct RuntimeEventBufferState {
    has_slot1: bool,
    slot1: RuntimeEvent,
    has_slot2: bool,
    slot2: RuntimeEvent,
    has_slot3: bool,
    slot3: RuntimeEvent,
    queued_count: i64,
    dropped_count: i64,
}

struct RuntimeEventBufferResult {
    state: RuntimeEventBufferState,
    applied: bool,
    reason_code: i64,
    event: RuntimeEvent,
}

struct RuntimeEventDequeueResult {
    state: RuntimeEventBufferState,
    has_event: bool,
    event: RuntimeEvent,
    reason_code: i64,
}

struct RuntimeIoChannelState {
    outbound_count: i64,
    db_write_count: i64,
    gc_suggest_count: i64,
    no_op_count: i64,
    rejected_dispatch_count: i64,
    last_subject_id: i64,
    last_io_kind: i64,
}

struct RuntimeIoChannelResult {
    state: RuntimeIoChannelState,
    applied: bool,
    reason_code: i64,
}

struct RuntimeDriverState {
    engine_state: RuntimeEngineState,
    host_state: RuntimeHostState,
    channel_state: RuntimeIoChannelState,
    buffer_state: RuntimeEventBufferState,
    step_count: i64,
    idle_step_count: i64,
    rejected_step_count: i64,
}

struct RuntimeDriverEnqueueResult {
    state: RuntimeDriverState,
    applied: bool,
    reason_code: i64,
}

struct RuntimeDriverResult {
    state: RuntimeDriverState,
    applied: bool,
    reason_code: i64,
    step: RuntimeStepResult,
    dequeued_event: RuntimeEvent,
}

def runtime_event_none() -> RuntimeEvent
ensures result.code == 0 && result.arg1 == 0 && result.arg2 == 0
{
    RuntimeEvent {
        code: 0,
        arg1: 0,
        arg2: 0,
    }
}

def runtime_event_buffer_capacity() -> i64
ensures result == 3
{
    3
}

def new_runtime_event_buffer_state() -> RuntimeEventBufferState
{
    RuntimeEventBufferState {
        has_slot1: false,
        slot1: runtime_event_none(),
        has_slot2: false,
        slot2: runtime_event_none(),
        has_slot3: false,
        slot3: runtime_event_none(),
        queued_count: 0,
        dropped_count: 0,
    }
}

def is_runtime_event_buffer_empty(buffer: RuntimeEventBufferState) -> bool
{
    buffer.queued_count == 0
}

def is_runtime_event_buffer_full(buffer: RuntimeEventBufferState) -> bool
{
    buffer.queued_count >= runtime_event_buffer_capacity()
}

def enqueue_runtime_event(
    buffer: RuntimeEventBufferState,
    event: RuntimeEvent,
) -> RuntimeEventBufferResult
{
    if !is_runtime_event_known(event.code) {
        RuntimeEventBufferResult {
            state: buffer,
            applied: false,
            reason_code: 7703,
            event: event,
        }
    } else {
        if is_runtime_event_buffer_full(buffer) {
            RuntimeEventBufferResult {
                state: RuntimeEventBufferState {
                    has_slot1: buffer.has_slot1,
                    slot1: buffer.slot1,
                    has_slot2: buffer.has_slot2,
                    slot2: buffer.slot2,
                    has_slot3: buffer.has_slot3,
                    slot3: buffer.slot3,
                    queued_count: buffer.queued_count,
                    dropped_count: buffer.dropped_count + 1,
                },
                applied: false,
                reason_code: 7701,
                event: event,
            }
        } else {
            if !buffer.has_slot1 {
                RuntimeEventBufferResult {
                    state: RuntimeEventBufferState {
                        has_slot1: true,
                        slot1: event,
                        has_slot2: buffer.has_slot2,
                        slot2: buffer.slot2,
                        has_slot3: buffer.has_slot3,
                        slot3: buffer.slot3,
                        queued_count: buffer.queued_count + 1,
                        dropped_count: buffer.dropped_count,
                    },
                    applied: true,
                    reason_code: 0,
                    event: event,
                }
            } else if !buffer.has_slot2 {
                RuntimeEventBufferResult {
                    state: RuntimeEventBufferState {
                        has_slot1: buffer.has_slot1,
                        slot1: buffer.slot1,
                        has_slot2: true,
                        slot2: event,
                        has_slot3: buffer.has_slot3,
                        slot3: buffer.slot3,
                        queued_count: buffer.queued_count + 1,
                        dropped_count: buffer.dropped_count,
                    },
                    applied: true,
                    reason_code: 0,
                    event: event,
                }
            } else {
                RuntimeEventBufferResult {
                    state: RuntimeEventBufferState {
                        has_slot1: buffer.has_slot1,
                        slot1: buffer.slot1,
                        has_slot2: buffer.has_slot2,
                        slot2: buffer.slot2,
                        has_slot3: true,
                        slot3: event,
                        queued_count: buffer.queued_count + 1,
                        dropped_count: buffer.dropped_count,
                    },
                    applied: true,
                    reason_code: 0,
                    event: event,
                }
            }
        }
    }
}

def dequeue_runtime_event(buffer: RuntimeEventBufferState) -> RuntimeEventDequeueResult
{
    if is_runtime_event_buffer_empty(buffer) {
        RuntimeEventDequeueResult {
            state: buffer,
            has_event: false,
            event: runtime_event_none(),
            reason_code: 7702,
        }
    } else {
        if !buffer.has_slot1 {
            RuntimeEventDequeueResult {
                state: RuntimeEventBufferState {
                    has_slot1: false,
                    slot1: runtime_event_none(),
                    has_slot2: false,
                    slot2: runtime_event_none(),
                    has_slot3: false,
                    slot3: runtime_event_none(),
                    queued_count: 0,
                    dropped_count: buffer.dropped_count,
                },
                has_event: false,
                event: runtime_event_none(),
                reason_code: 7702,
            }
        } else {
            if buffer.has_slot2 {
                if buffer.has_slot3 {
                    RuntimeEventDequeueResult {
                        state: RuntimeEventBufferState {
                            has_slot1: true,
                            slot1: buffer.slot2,
                            has_slot2: true,
                            slot2: buffer.slot3,
                            has_slot3: false,
                            slot3: runtime_event_none(),
                            queued_count: buffer.queued_count - 1,
                            dropped_count: buffer.dropped_count,
                        },
                        has_event: true,
                        event: buffer.slot1,
                        reason_code: 0,
                    }
                } else {
                    RuntimeEventDequeueResult {
                        state: RuntimeEventBufferState {
                            has_slot1: true,
                            slot1: buffer.slot2,
                            has_slot2: false,
                            slot2: runtime_event_none(),
                            has_slot3: false,
                            slot3: runtime_event_none(),
                            queued_count: buffer.queued_count - 1,
                            dropped_count: buffer.dropped_count,
                        },
                        has_event: true,
                        event: buffer.slot1,
                        reason_code: 0,
                    }
                }
            } else {
                if buffer.has_slot3 {
                    RuntimeEventDequeueResult {
                        state: RuntimeEventBufferState {
                            has_slot1: true,
                            slot1: buffer.slot3,
                            has_slot2: false,
                            slot2: runtime_event_none(),
                            has_slot3: false,
                            slot3: runtime_event_none(),
                            queued_count: buffer.queued_count - 1,
                            dropped_count: buffer.dropped_count,
                        },
                        has_event: true,
                        event: buffer.slot1,
                        reason_code: 0,
                    }
                } else {
                    RuntimeEventDequeueResult {
                        state: RuntimeEventBufferState {
                            has_slot1: false,
                            slot1: runtime_event_none(),
                            has_slot2: false,
                            slot2: runtime_event_none(),
                            has_slot3: false,
                            slot3: runtime_event_none(),
                            queued_count: buffer.queued_count - 1,
                            dropped_count: buffer.dropped_count,
                        },
                        has_event: true,
                        event: buffer.slot1,
                        reason_code: 0,
                    }
                }
            }
        }
    }
}

def new_runtime_io_channel_state() -> RuntimeIoChannelState
{
    RuntimeIoChannelState {
        outbound_count: 0,
        db_write_count: 0,
        gc_suggest_count: 0,
        no_op_count: 0,
        rejected_dispatch_count: 0,
        last_subject_id: 0,
        last_io_kind: runtime_io_kind_none(),
    }
}

def apply_runtime_io_dispatch_to_channel(
    channel: RuntimeIoChannelState,
    dispatch: RuntimeIoDispatch,
) -> RuntimeIoChannelResult
{
    if !should_runtime_emit_io(dispatch) {
        RuntimeIoChannelResult {
            state: RuntimeIoChannelState {
                outbound_count: channel.outbound_count,
                db_write_count: channel.db_write_count,
                gc_suggest_count: channel.gc_suggest_count,
                no_op_count: channel.no_op_count + 1,
                rejected_dispatch_count: channel.rejected_dispatch_count + 1,
                last_subject_id: channel.last_subject_id,
                last_io_kind: channel.last_io_kind,
            },
            applied: false,
            reason_code: 7801,
        }
    } else {
        let op = dispatch.op;
        let next_outbound = if op.kind == runtime_io_kind_room_changed()
            || op.kind == runtime_io_kind_room_started()
            || op.kind == runtime_io_kind_heartbeat_ack()
            || op.kind == runtime_io_kind_player_disconnected()
        {
            channel.outbound_count + 1
        } else {
            channel.outbound_count
        };
        let next_db_write = if op.kind == runtime_io_kind_task_issued()
            || op.kind == runtime_io_kind_task_finished()
        {
            channel.db_write_count + 1
        } else {
            channel.db_write_count
        };
        let next_gc = if op.kind == runtime_io_kind_gc_suggested() {
            channel.gc_suggest_count + 1
        } else {
            channel.gc_suggest_count
        };

        RuntimeIoChannelResult {
            state: RuntimeIoChannelState {
                outbound_count: next_outbound,
                db_write_count: next_db_write,
                gc_suggest_count: next_gc,
                no_op_count: channel.no_op_count,
                rejected_dispatch_count: channel.rejected_dispatch_count,
                last_subject_id: op.subject_id,
                last_io_kind: op.kind,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def new_runtime_driver_state(initial_engine_state: RuntimeEngineState) -> RuntimeDriverState
{
    RuntimeDriverState {
        engine_state: initial_engine_state,
        host_state: new_runtime_host_state(),
        channel_state: new_runtime_io_channel_state(),
        buffer_state: new_runtime_event_buffer_state(),
        step_count: 0,
        idle_step_count: 0,
        rejected_step_count: 0,
    }
}

def make_runtime_noop_step(
    runtime_state: RuntimeEngineState,
    host_state: RuntimeHostState,
    reason_code: i64,
    event_code: i64,
) -> RuntimeStepResult
{
    let engine_result = RuntimeEngineResult {
        state: runtime_state,
        applied: false,
        reason_code: reason_code,
        event_code: event_code,
    };
    let io_dispatch = build_runtime_io_dispatch(runtime_state, engine_result);
    RuntimeStepResult {
        engine_result: engine_result,
        io_dispatch: io_dispatch,
        host_result: RuntimeHostResult {
            state: host_state,
            applied: false,
            reason_code: 7501,
        },
    }
}

def enqueue_runtime_driver_event(
    driver_state: RuntimeDriverState,
    event: RuntimeEvent,
) -> RuntimeDriverEnqueueResult
{
    let enqueue_result = enqueue_runtime_event(driver_state.buffer_state, event);
    let rejected_next = if enqueue_result.applied {
        driver_state.rejected_step_count
    } else {
        driver_state.rejected_step_count + 1
    };
    RuntimeDriverEnqueueResult {
        state: RuntimeDriverState {
            engine_state: driver_state.engine_state,
            host_state: driver_state.host_state,
            channel_state: driver_state.channel_state,
            buffer_state: enqueue_result.state,
            step_count: driver_state.step_count,
            idle_step_count: driver_state.idle_step_count,
            rejected_step_count: rejected_next,
        },
        applied: enqueue_result.applied,
        reason_code: enqueue_result.reason_code,
    }
}

def step_runtime_driver(driver_state: RuntimeDriverState) -> RuntimeDriverResult
{
    let dequeued = dequeue_runtime_event(driver_state.buffer_state);
    if !dequeued.has_event {
        RuntimeDriverResult {
            state: RuntimeDriverState {
                engine_state: driver_state.engine_state,
                host_state: driver_state.host_state,
                channel_state: driver_state.channel_state,
                buffer_state: dequeued.state,
                step_count: driver_state.step_count,
                idle_step_count: driver_state.idle_step_count + 1,
                rejected_step_count: driver_state.rejected_step_count,
            },
            applied: false,
            reason_code: 7702,
            step: make_runtime_noop_step(driver_state.engine_state, driver_state.host_state, 7702, 0),
            dequeued_event: runtime_event_none(),
        }
    } else {
        let step = apply_runtime_step_record(driver_state.engine_state, driver_state.host_state, dequeued.event);
        let channel_result = apply_runtime_io_dispatch_to_channel(driver_state.channel_state, step.io_dispatch);
        let rejected_next = if step.engine_result.applied {
            driver_state.rejected_step_count
        } else {
            driver_state.rejected_step_count + 1
        };
        RuntimeDriverResult {
            state: RuntimeDriverState {
                engine_state: step.engine_result.state,
                host_state: step.host_result.state,
                channel_state: channel_result.state,
                buffer_state: dequeued.state,
                step_count: driver_state.step_count + 1,
                idle_step_count: driver_state.idle_step_count,
                rejected_step_count: rejected_next,
            },
            applied: step.engine_result.applied,
            reason_code: step.engine_result.reason_code,
            step: step,
            dequeued_event: dequeued.event,
        }
    }
}

def push_and_step_runtime_driver(
    driver_state: RuntimeDriverState,
    event: RuntimeEvent,
) -> RuntimeDriverResult
{
    let enqueue_result = enqueue_runtime_driver_event(driver_state, event);
    if !enqueue_result.applied {
        RuntimeDriverResult {
            state: enqueue_result.state,
            applied: false,
            reason_code: enqueue_result.reason_code,
            step: make_runtime_noop_step(
                enqueue_result.state.engine_state,
                enqueue_result.state.host_state,
                enqueue_result.reason_code,
                event.code,
            ),
            dequeued_event: runtime_event_none(),
        }
    } else {
        step_runtime_driver(enqueue_result.state)
    }
}

def apply_runtime_driver_warning_tick(
    driver_state: RuntimeDriverState,
    should_warn: bool,
) -> RuntimeDriverState
{
    let warning_result = apply_runtime_warning_tick(driver_state.host_state, should_warn);
    let next_host = if warning_result.applied {
        warning_result.state
    } else {
        driver_state.host_state
    };
    RuntimeDriverState {
        engine_state: driver_state.engine_state,
        host_state: next_host,
        channel_state: driver_state.channel_state,
        buffer_state: driver_state.buffer_state,
        step_count: driver_state.step_count,
        idle_step_count: driver_state.idle_step_count,
        rejected_step_count: driver_state.rejected_step_count,
    }
}

def should_runtime_driver_shutdown(driver_state: RuntimeDriverState) -> bool
{
    should_runtime_shutdown(driver_state.host_state) || driver_state.buffer_state.dropped_count >= 3
}

struct RuntimeWireFrame {
    packet_type: i64,
    opcode: i64,
    conn_id: i64,
    arg1: i64,
    arg2: i64,
    request_id: i64,
}

struct RuntimeIngressResult {
    accepted: bool,
    reason_code: i64,
    event: RuntimeEvent,
    frame: RuntimeWireFrame,
}

struct RuntimeIngressDriverResult {
    ingress: RuntimeIngressResult,
    driver: RuntimeDriverResult,
}

struct RuntimeWireOutbound {
    sendable: bool,
    conn_id: i64,
    opcode: i64,
    payload_a: i64,
    payload_b: i64,
    reason_code: i64,
}

def runtime_wire_packet_type_request() -> i64
ensures result == 0x100
{
    0x100
}

def runtime_wire_packet_type_notification() -> i64
ensures result == 0x400
{
    0x400
}

def runtime_wire_opcode_room_join() -> i64
ensures result == 2101
{
    2101
}

def runtime_wire_opcode_room_leave() -> i64
ensures result == 2102
{
    2102
}

def runtime_wire_opcode_room_start() -> i64
ensures result == 2103
{
    2103
}

def runtime_wire_opcode_room_mark_outdated() -> i64
ensures result == 2104
{
    2104
}

def runtime_wire_opcode_player_heartbeat() -> i64
ensures result == 2105
{
    2105
}

def runtime_wire_opcode_player_disconnect() -> i64
ensures result == 2106
{
    2106
}

def runtime_wire_opcode_task_issue() -> i64
ensures result == 2107
{
    2107
}

def runtime_wire_opcode_task_finish() -> i64
ensures result == 2108
{
    2108
}

def runtime_wire_opcode_task_abort_all() -> i64
ensures result == 2109
{
    2109
}

def runtime_wire_opcode_player_enter_game() -> i64
ensures result == 2110
{
    2110
}

def runtime_wire_opcode_player_set_dead() -> i64
ensures result == 2111
{
    2111
}

def runtime_wire_opcode_room_set_lua_ref() -> i64
ensures result == 2112
{
    2112
}

def runtime_wire_opcode_player_ttl_tick() -> i64
ensures result == 2113
{
    2113
}

def runtime_wire_outbound_opcode_room_changed() -> i64
ensures result == 2201
{
    2201
}

def runtime_wire_outbound_opcode_room_started() -> i64
ensures result == 2202
{
    2202
}

def runtime_wire_outbound_opcode_heartbeat_ack() -> i64
ensures result == 2203
{
    2203
}

def runtime_wire_outbound_opcode_player_disconnected() -> i64
ensures result == 2204
{
    2204
}

def runtime_wire_outbound_opcode_task_issued() -> i64
ensures result == 2205
{
    2205
}

def runtime_wire_outbound_opcode_task_finished() -> i64
ensures result == 2206
{
    2206
}

def runtime_wire_outbound_opcode_gc_suggested() -> i64
ensures result == 2207
{
    2207
}

def make_runtime_wire_frame(
    packet_type: i64,
    opcode: i64,
    conn_id: i64,
    arg1: i64,
    arg2: i64,
    request_id: i64,
) -> RuntimeWireFrame
{
    RuntimeWireFrame {
        packet_type: packet_type,
        opcode: opcode,
        conn_id: conn_id,
        arg1: arg1,
        arg2: arg2,
        request_id: request_id,
    }
}

def is_runtime_wire_packet_type_supported(packet_type: i64) -> bool
{
    packet_type == runtime_wire_packet_type_request()
        || packet_type == runtime_wire_packet_type_notification()
}

def make_runtime_ingress_accept(frame: RuntimeWireFrame, event: RuntimeEvent) -> RuntimeIngressResult
{
    RuntimeIngressResult {
        accepted: true,
        reason_code: 0,
        event: event,
        frame: frame,
    }
}

def make_runtime_ingress_reject(frame: RuntimeWireFrame, reason_code: i64) -> RuntimeIngressResult
{
    RuntimeIngressResult {
        accepted: false,
        reason_code: reason_code,
        event: runtime_event_none(),
        frame: frame,
    }
}

def decode_runtime_wire_frame(frame: RuntimeWireFrame) -> RuntimeIngressResult
{
    if frame.conn_id <= 0 {
        make_runtime_ingress_reject(frame, 7901)
    } else if !is_runtime_wire_packet_type_supported(frame.packet_type) {
        make_runtime_ingress_reject(frame, 7903)
    } else {
        if frame.opcode == runtime_wire_opcode_room_join() {
            make_runtime_ingress_accept(
                frame,
                make_runtime_event(runtime_event_room_join(), frame.arg1, frame.arg2),
            )
        } else if frame.opcode == runtime_wire_opcode_room_leave() {
            make_runtime_ingress_accept(
                frame,
                make_runtime_event(runtime_event_room_leave(), frame.arg1, frame.arg2),
            )
        } else if frame.opcode == runtime_wire_opcode_room_start() {
            make_runtime_ingress_accept(
                frame,
                make_runtime_event(runtime_event_room_start(), 0, 0),
            )
        } else if frame.opcode == runtime_wire_opcode_room_mark_outdated() {
            make_runtime_ingress_accept(
                frame,
                make_runtime_event(runtime_event_room_mark_outdated(), frame.arg1, frame.arg2),
            )
        } else if frame.opcode == runtime_wire_opcode_player_heartbeat() {
            make_runtime_ingress_accept(
                frame,
                make_runtime_event(runtime_event_player_heartbeat(), frame.arg1, frame.arg2),
            )
        } else if frame.opcode == runtime_wire_opcode_player_disconnect() {
            make_runtime_ingress_accept(
                frame,
                make_runtime_event(runtime_event_player_disconnect(), 0, 0),
            )
        } else if frame.opcode == runtime_wire_opcode_task_issue() {
            make_runtime_ingress_accept(
                frame,
                make_runtime_event(runtime_event_task_issue(), frame.conn_id, frame.arg1),
            )
        } else if frame.opcode == runtime_wire_opcode_task_finish() {
            make_runtime_ingress_accept(
                frame,
                make_runtime_event(runtime_event_task_finish(), frame.arg1, 0),
            )
        } else if frame.opcode == runtime_wire_opcode_task_abort_all() {
            make_runtime_ingress_accept(
                frame,
                make_runtime_event(runtime_event_task_abort_all(), 0, 0),
            )
        } else if frame.opcode == runtime_wire_opcode_player_enter_game() {
            make_runtime_ingress_accept(
                frame,
                make_runtime_event(runtime_event_player_enter_game(), 0, 0),
            )
        } else if frame.opcode == runtime_wire_opcode_player_set_dead() {
            make_runtime_ingress_accept(
                frame,
                make_runtime_event(runtime_event_player_set_dead(), frame.arg1, 0),
            )
        } else if frame.opcode == runtime_wire_opcode_room_set_lua_ref() {
            make_runtime_ingress_accept(
                frame,
                make_runtime_event(runtime_event_room_set_lua_ref(), frame.arg1, 0),
            )
        } else if frame.opcode == runtime_wire_opcode_player_ttl_tick() {
            make_runtime_ingress_accept(
                frame,
                make_runtime_event(runtime_event_player_ttl_tick(), 0, 0),
            )
        } else {
            make_runtime_ingress_reject(frame, 7902)
        }
    }
}

def ingest_runtime_wire_frame(
    driver_state: RuntimeDriverState,
    frame: RuntimeWireFrame,
) -> RuntimeIngressDriverResult
{
    let ingress = decode_runtime_wire_frame(frame);
    if !ingress.accepted {
        RuntimeIngressDriverResult {
            ingress: ingress,
            driver: RuntimeDriverResult {
                state: RuntimeDriverState {
                    engine_state: driver_state.engine_state,
                    host_state: driver_state.host_state,
                    channel_state: driver_state.channel_state,
                    buffer_state: driver_state.buffer_state,
                    step_count: driver_state.step_count,
                    idle_step_count: driver_state.idle_step_count,
                    rejected_step_count: driver_state.rejected_step_count + 1,
                },
                applied: false,
                reason_code: ingress.reason_code,
                step: make_runtime_noop_step(
                    driver_state.engine_state,
                    driver_state.host_state,
                    ingress.reason_code,
                    frame.opcode,
                ),
                dequeued_event: runtime_event_none(),
            },
        }
    } else {
        RuntimeIngressDriverResult {
            ingress: ingress,
            driver: push_and_step_runtime_driver(driver_state, ingress.event),
        }
    }
}

def runtime_wire_outbound_opcode_from_io_kind(io_kind: i64) -> i64
{
    if io_kind == runtime_io_kind_room_changed() {
        runtime_wire_outbound_opcode_room_changed()
    } else if io_kind == runtime_io_kind_room_started() {
        runtime_wire_outbound_opcode_room_started()
    } else if io_kind == runtime_io_kind_heartbeat_ack() {
        runtime_wire_outbound_opcode_heartbeat_ack()
    } else if io_kind == runtime_io_kind_player_disconnected() {
        runtime_wire_outbound_opcode_player_disconnected()
    } else if io_kind == runtime_io_kind_task_issued() {
        runtime_wire_outbound_opcode_task_issued()
    } else if io_kind == runtime_io_kind_task_finished() {
        runtime_wire_outbound_opcode_task_finished()
    } else if io_kind == runtime_io_kind_gc_suggested() {
        runtime_wire_outbound_opcode_gc_suggested()
    } else {
        0
    }
}

def build_runtime_wire_outbound(dispatch: RuntimeIoDispatch) -> RuntimeWireOutbound
{
    if !should_runtime_emit_io(dispatch) {
        RuntimeWireOutbound {
            sendable: false,
            conn_id: 0,
            opcode: 0,
            payload_a: 0,
            payload_b: 0,
            reason_code: 7911,
        }
    } else {
        let op = dispatch.op;
        let opcode = runtime_wire_outbound_opcode_from_io_kind(op.kind);
        if opcode == 0 {
            RuntimeWireOutbound {
                sendable: false,
                conn_id: op.subject_id,
                opcode: 0,
                payload_a: op.value_a,
                payload_b: op.value_b,
                reason_code: 7912,
            }
        } else {
            RuntimeWireOutbound {
                sendable: true,
                conn_id: op.subject_id,
                opcode: opcode,
                payload_a: op.value_a,
                payload_b: op.value_b,
                reason_code: 0,
            }
        }
    }
}

struct RoomRuntimeState {
    session_id: i64,
    capacity: i64,
    player_count: i64,
    online_human_count: i64,
    started: bool,
    outdated: bool,
    owner_conn_id: i64,
    lua_ref_count: i64,
}

struct RoomTransitionResult {
    state: RoomRuntimeState,
    applied: bool,
    reason_code: i64,
}

struct PlayerRuntimeState {
    conn_id: i64,
    state_code: i64,
    ttl: i64,
    inside_game: bool,
    is_died: bool,
}

struct PlayerTransitionResult {
    state: PlayerRuntimeState,
    applied: bool,
    reason_code: i64,
}

struct TaskRuntimeState {
    next_task_id: i64,
    active_task_count: i64,
    pending_reply_count: i64,
}

struct TaskTransitionResult {
    state: TaskRuntimeState,
    applied: bool,
    reason_code: i64,
    issued_task_id: i64,
}

def new_room_runtime_state(capacity: i64, owner_conn_id: i64, next_session_id: i64) -> RoomRuntimeState
requires capacity > 0 && owner_conn_id >= 0 && next_session_id >= 0
ensures result.capacity == capacity && result.player_count == 0 && result.started == false && result.outdated == false
{
    RoomRuntimeState {
        session_id: next_session_id,
        capacity: capacity,
        player_count: 0,
        online_human_count: 0,
        started: false,
        outdated: false,
        owner_conn_id: owner_conn_id,
        lua_ref_count: 0,
    }
}

def apply_room_join(state: RoomRuntimeState, joiner_online: bool) -> RoomTransitionResult
requires state.capacity > 0 && state.player_count >= 0 && state.online_human_count >= 0
{
    if !joiner_online {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7101,
        }
    } else if state.started {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7102,
        }
    } else if state.outdated {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7103,
        }
    } else if state.player_count >= state.capacity {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7104,
        }
    } else {
        RoomTransitionResult {
            state: RoomRuntimeState {
                session_id: state.session_id,
                capacity: state.capacity,
                player_count: state.player_count + 1,
                online_human_count: state.online_human_count + 1,
                started: state.started,
                outdated: state.outdated,
                owner_conn_id: state.owner_conn_id,
                lua_ref_count: state.lua_ref_count,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_room_leave(state: RoomRuntimeState, leaving_online_human: bool) -> RoomTransitionResult
requires state.capacity > 0 && state.player_count >= 0 && state.online_human_count >= 0
{
    if state.player_count == 0 {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7105,
        }
    } else {
        let next_player_count = state.player_count - 1;
        let next_online_human_count = if leaving_online_human && state.online_human_count > 0 {
            state.online_human_count - 1
        } else {
            state.online_human_count
        };
        let next_owner_conn_id = if next_player_count == 0 {
            0
        } else {
            state.owner_conn_id
        };
        let next_started = if next_player_count == 0 {
            false
        } else {
            state.started
        };
        RoomTransitionResult {
            state: RoomRuntimeState {
                session_id: state.session_id,
                capacity: state.capacity,
                player_count: next_player_count,
                online_human_count: next_online_human_count,
                started: next_started,
                outdated: state.outdated,
                owner_conn_id: next_owner_conn_id,
                lua_ref_count: state.lua_ref_count,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_room_start(state: RoomRuntimeState) -> RoomTransitionResult
requires state.capacity > 0 && state.player_count >= 0
{
    if state.started {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7106,
        }
    } else if state.outdated {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7107,
        }
    } else if state.player_count != state.capacity {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7108,
        }
    } else {
        RoomTransitionResult {
            state: RoomRuntimeState {
                session_id: state.session_id,
                capacity: state.capacity,
                player_count: state.player_count,
                online_human_count: state.online_human_count,
                started: true,
                outdated: state.outdated,
                owner_conn_id: state.owner_conn_id,
                lua_ref_count: state.lua_ref_count,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_room_mark_outdated(state: RoomRuntimeState, md5_matches_server: bool) -> RoomTransitionResult
{
    if md5_matches_server {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7109,
        }
    } else if state.outdated {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7110,
        }
    } else {
        RoomTransitionResult {
            state: RoomRuntimeState {
                session_id: state.session_id,
                capacity: state.capacity,
                player_count: state.player_count,
                online_human_count: state.online_human_count,
                started: state.started,
                outdated: true,
                owner_conn_id: state.owner_conn_id,
                lua_ref_count: state.lua_ref_count,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_room_set_lua_ref_count(state: RoomRuntimeState, lua_ref_count: i64) -> RoomTransitionResult
requires lua_ref_count >= 0
{
    if state.lua_ref_count == lua_ref_count {
        RoomTransitionResult {
            state: state,
            applied: false,
            reason_code: 7111,
        }
    } else {
        RoomTransitionResult {
            state: RoomRuntimeState {
                session_id: state.session_id,
                capacity: state.capacity,
                player_count: state.player_count,
                online_human_count: state.online_human_count,
                started: state.started,
                outdated: state.outdated,
                owner_conn_id: state.owner_conn_id,
                lua_ref_count: lua_ref_count,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def should_collect_room_runtime(state: RoomRuntimeState) -> bool
{
    let abandoned = state.player_count == 0 || state.online_human_count == 0;
    abandoned && state.lua_ref_count == 0
}

def can_dispatch_room_rpc(state: RoomRuntimeState) -> bool
{
    state.started && !state.outdated && state.online_human_count > 0
}

def new_player_runtime_state(conn_id: i64, initial_ttl: i64, initial_state_code: i64) -> PlayerRuntimeState
requires conn_id >= 0 && initial_ttl >= 0 && initial_state_code >= 0 && initial_state_code <= 6
{
    PlayerRuntimeState {
        conn_id: conn_id,
        state_code: initial_state_code,
        ttl: initial_ttl,
        inside_game: false,
        is_died: false,
    }
}

def apply_player_heartbeat(state: PlayerRuntimeState, max_ttl: i64) -> PlayerTransitionResult
requires max_ttl >= 0
{
    if max_ttl == 0 {
        PlayerTransitionResult {
            state: state,
            applied: false,
            reason_code: 7201,
        }
    } else {
        let next_state_code = if state.state_code == 6 {
            1
        } else {
            state.state_code
        };
        PlayerTransitionResult {
            state: PlayerRuntimeState {
                conn_id: state.conn_id,
                state_code: next_state_code,
                ttl: max_ttl,
                inside_game: state.inside_game,
                is_died: state.is_died,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_player_disconnect(state: PlayerRuntimeState) -> PlayerTransitionResult
{
    if state.state_code == 6 {
        PlayerTransitionResult {
            state: state,
            applied: false,
            reason_code: 7202,
        }
    } else {
        let mark_run = state.inside_game && !state.is_died;
        let next_state_code = if mark_run {
            5
        } else {
            6
        };
        PlayerTransitionResult {
            state: PlayerRuntimeState {
                conn_id: state.conn_id,
                state_code: next_state_code,
                ttl: 0,
                inside_game: mark_run,
                is_died: state.is_died,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_player_set_dead(state: PlayerRuntimeState, is_died: bool) -> PlayerTransitionResult
{
    if state.is_died == is_died {
        PlayerTransitionResult {
            state: state,
            applied: false,
            reason_code: 7203,
        }
    } else {
        PlayerTransitionResult {
            state: PlayerRuntimeState {
                conn_id: state.conn_id,
                state_code: state.state_code,
                ttl: state.ttl,
                inside_game: state.inside_game,
                is_died: is_died,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_player_enter_game(state: PlayerRuntimeState) -> PlayerTransitionResult
{
    if state.state_code == 6 {
        PlayerTransitionResult {
            state: state,
            applied: false,
            reason_code: 7204,
        }
    } else if state.inside_game {
        PlayerTransitionResult {
            state: state,
            applied: false,
            reason_code: 7205,
        }
    } else {
        PlayerTransitionResult {
            state: PlayerRuntimeState {
                conn_id: state.conn_id,
                state_code: state.state_code,
                ttl: state.ttl,
                inside_game: true,
                is_died: state.is_died,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_player_ttl_tick(state: PlayerRuntimeState) -> PlayerTransitionResult
{
    if state.ttl == 0 {
        PlayerTransitionResult {
            state: state,
            applied: false,
            reason_code: 7206,
        }
    } else {
        let next_ttl = state.ttl - 1;
        let next_state_code = if next_ttl == 0 {
            6
        } else {
            state.state_code
        };
        let next_inside_game = if next_ttl == 0 {
            false
        } else {
            state.inside_game
        };
        PlayerTransitionResult {
            state: PlayerRuntimeState {
                conn_id: state.conn_id,
                state_code: next_state_code,
                ttl: next_ttl,
                inside_game: next_inside_game,
                is_died: state.is_died,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def can_player_accept_request(state: PlayerRuntimeState) -> bool
{
    let active_state = state.state_code == 1 || state.state_code == 2 || state.state_code == 3;
    active_state && state.ttl > 0
}

def new_task_runtime_state(start_task_id: i64) -> TaskRuntimeState
requires start_task_id <= -1
{
    TaskRuntimeState {
        next_task_id: start_task_id,
        active_task_count: 0,
        pending_reply_count: 0,
    }
}

def apply_issue_task(state: TaskRuntimeState, conn_id: i64, track_request_id: bool) -> TaskTransitionResult
{
    if conn_id <= 0 {
        TaskTransitionResult {
            state: state,
            applied: false,
            reason_code: 7301,
            issued_task_id: -1,
        }
    } else {
        let next_pending_reply_count = if track_request_id {
            state.pending_reply_count + 1
        } else {
            state.pending_reply_count
        };
        TaskTransitionResult {
            state: TaskRuntimeState {
                next_task_id: state.next_task_id - 1,
                active_task_count: state.active_task_count + 1,
                pending_reply_count: next_pending_reply_count,
            },
            applied: true,
            reason_code: 0,
            issued_task_id: state.next_task_id,
        }
    }
}

def apply_finish_task(state: TaskRuntimeState, had_pending_reply: bool) -> TaskTransitionResult
{
    if state.active_task_count == 0 {
        TaskTransitionResult {
            state: state,
            applied: false,
            reason_code: 7302,
            issued_task_id: -1,
        }
    } else {
        let next_pending_reply_count = if had_pending_reply && state.pending_reply_count > 0 {
            state.pending_reply_count - 1
        } else {
            state.pending_reply_count
        };
        TaskTransitionResult {
            state: TaskRuntimeState {
                next_task_id: state.next_task_id,
                active_task_count: state.active_task_count - 1,
                pending_reply_count: next_pending_reply_count,
            },
            applied: true,
            reason_code: 0,
            issued_task_id: -1,
        }
    }
}

def apply_abort_all_tasks(state: TaskRuntimeState) -> TaskTransitionResult
{
    if state.active_task_count == 0 && state.pending_reply_count == 0 {
        TaskTransitionResult {
            state: state,
            applied: false,
            reason_code: 7303,
            issued_task_id: -1,
        }
    } else {
        TaskTransitionResult {
            state: TaskRuntimeState {
                next_task_id: state.next_task_id,
                active_task_count: 0,
                pending_reply_count: 0,
            },
            applied: true,
            reason_code: 0,
            issued_task_id: -1,
        }
    }
}

def can_gc_user_task_bucket(state: TaskRuntimeState) -> bool
{
    state.active_task_count == 0
}

def can_lookup_reply_mapping(state: TaskRuntimeState) -> bool
{
    state.pending_reply_count > 0
}

struct RuntimeEngineState {
    room: RoomRuntimeState,
    player: PlayerRuntimeState,
    task: TaskRuntimeState,
}

struct RuntimeEngineResult {
    state: RuntimeEngineState,
    applied: bool,
    reason_code: i64,
    event_code: i64,
}

def bool_from_flag(flag: i64) -> bool
{
    flag != 0
}

def normalize_non_negative_i64(value: i64) -> i64
{
    if value < 0 {
        0
    } else {
        value
    }
}

def new_runtime_engine_state(
    room_capacity: i64,
    owner_conn_id: i64,
    first_session_id: i64,
    conn_id: i64,
    initial_ttl: i64,
    initial_state_code: i64,
    start_task_id: i64,
) -> RuntimeEngineState
{
    RuntimeEngineState {
        room: new_room_runtime_state(room_capacity, owner_conn_id, first_session_id),
        player: new_player_runtime_state(conn_id, initial_ttl, initial_state_code),
        task: new_task_runtime_state(start_task_id),
    }
}

def apply_runtime_event(state: RuntimeEngineState, event_code: i64, arg1: i64, arg2: i64) -> RuntimeEngineResult
{
    if event_code == 1 {
        let room_result = apply_room_join(state.room, bool_from_flag(arg1));
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: room_result.state,
                player: state.player,
                task: state.task,
            },
            applied: room_result.applied,
            reason_code: room_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 2 {
        let room_result = apply_room_leave(state.room, bool_from_flag(arg1));
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: room_result.state,
                player: state.player,
                task: state.task,
            },
            applied: room_result.applied,
            reason_code: room_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 3 {
        let room_result = apply_room_start(state.room);
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: room_result.state,
                player: state.player,
                task: state.task,
            },
            applied: room_result.applied,
            reason_code: room_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 4 {
        let room_result = apply_room_mark_outdated(state.room, bool_from_flag(arg1));
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: room_result.state,
                player: state.player,
                task: state.task,
            },
            applied: room_result.applied,
            reason_code: room_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 5 {
        let player_result = apply_player_heartbeat(state.player, normalize_non_negative_i64(arg1));
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: state.room,
                player: player_result.state,
                task: state.task,
            },
            applied: player_result.applied,
            reason_code: player_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 6 {
        let player_result = apply_player_disconnect(state.player);
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: state.room,
                player: player_result.state,
                task: state.task,
            },
            applied: player_result.applied,
            reason_code: player_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 7 {
        let task_result = apply_issue_task(state.task, arg1, bool_from_flag(arg2));
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: state.room,
                player: state.player,
                task: task_result.state,
            },
            applied: task_result.applied,
            reason_code: task_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 8 {
        let task_result = apply_finish_task(state.task, bool_from_flag(arg1));
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: state.room,
                player: state.player,
                task: task_result.state,
            },
            applied: task_result.applied,
            reason_code: task_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 9 {
        let task_result = apply_abort_all_tasks(state.task);
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: state.room,
                player: state.player,
                task: task_result.state,
            },
            applied: task_result.applied,
            reason_code: task_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 10 {
        let player_result = apply_player_enter_game(state.player);
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: state.room,
                player: player_result.state,
                task: state.task,
            },
            applied: player_result.applied,
            reason_code: player_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 11 {
        let player_result = apply_player_set_dead(state.player, bool_from_flag(arg1));
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: state.room,
                player: player_result.state,
                task: state.task,
            },
            applied: player_result.applied,
            reason_code: player_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 12 {
        let room_result = apply_room_set_lua_ref_count(state.room, normalize_non_negative_i64(arg1));
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: room_result.state,
                player: state.player,
                task: state.task,
            },
            applied: room_result.applied,
            reason_code: room_result.reason_code,
            event_code: event_code,
        }
    } else if event_code == 13 {
        let player_result = apply_player_ttl_tick(state.player);
        RuntimeEngineResult {
            state: RuntimeEngineState {
                room: state.room,
                player: player_result.state,
                task: state.task,
            },
            applied: player_result.applied,
            reason_code: player_result.reason_code,
            event_code: event_code,
        }
    } else {
        RuntimeEngineResult {
            state: state,
            applied: false,
            reason_code: 7999,
            event_code: event_code,
        }
    }
}

def can_runtime_dispatch_rpc(state: RuntimeEngineState) -> bool
{
    can_dispatch_room_rpc(state.room) && can_player_accept_request(state.player)
}

def should_runtime_collect_gc(state: RuntimeEngineState) -> bool
{
    should_collect_room_runtime(state.room) && can_gc_user_task_bucket(state.task)
}

def should_runtime_emit_heartbeat_warning(state: RuntimeEngineState) -> bool
{
    state.player.state_code != 6 && state.player.ttl <= 1
}

struct RuntimeIoOp {
    kind: i64,
    subject_id: i64,
    value_a: i64,
    value_b: i64,
    immediate: bool,
}

struct RuntimeIoDispatch {
    has_op: bool,
    op: RuntimeIoOp,
    reason_code: i64,
}

def runtime_io_kind_none() -> i64
ensures result == 0
{
    0
}

def runtime_io_kind_room_changed() -> i64
ensures result == 1001
{
    1001
}

def runtime_io_kind_room_started() -> i64
ensures result == 1002
{
    1002
}

def runtime_io_kind_heartbeat_ack() -> i64
ensures result == 1003
{
    1003
}

def runtime_io_kind_player_disconnected() -> i64
ensures result == 1004
{
    1004
}

def runtime_io_kind_task_issued() -> i64
ensures result == 1101
{
    1101
}

def runtime_io_kind_task_finished() -> i64
ensures result == 1102
{
    1102
}

def runtime_io_kind_gc_suggested() -> i64
ensures result == 1201
{
    1201
}

def empty_runtime_io_op() -> RuntimeIoOp
{
    RuntimeIoOp {
        kind: runtime_io_kind_none(),
        subject_id: 0,
        value_a: 0,
        value_b: 0,
        immediate: false,
    }
}

def build_runtime_io_dispatch(previous_state: RuntimeEngineState, event_result: RuntimeEngineResult) -> RuntimeIoDispatch
{
    let state = event_result.state;
    if !event_result.applied {
        RuntimeIoDispatch {
            has_op: false,
            op: empty_runtime_io_op(),
            reason_code: 7401,
        }
    } else if event_result.event_code == 1 || event_result.event_code == 2 {
        RuntimeIoDispatch {
            has_op: true,
            op: RuntimeIoOp {
                kind: runtime_io_kind_room_changed(),
                subject_id: state.room.session_id,
                value_a: state.room.player_count,
                value_b: state.room.online_human_count,
                immediate: true,
            },
            reason_code: 0,
        }
    } else if event_result.event_code == 3 {
        RuntimeIoDispatch {
            has_op: true,
            op: RuntimeIoOp {
                kind: runtime_io_kind_room_started(),
                subject_id: state.room.session_id,
                value_a: state.room.player_count,
                value_b: state.room.capacity,
                immediate: true,
            },
            reason_code: 0,
        }
    } else if event_result.event_code == 5 {
        RuntimeIoDispatch {
            has_op: true,
            op: RuntimeIoOp {
                kind: runtime_io_kind_heartbeat_ack(),
                subject_id: state.player.conn_id,
                value_a: state.player.ttl,
                value_b: 0,
                immediate: true,
            },
            reason_code: 0,
        }
    } else if event_result.event_code == 6 {
        RuntimeIoDispatch {
            has_op: true,
            op: RuntimeIoOp {
                kind: runtime_io_kind_player_disconnected(),
                subject_id: state.player.conn_id,
                value_a: state.player.state_code,
                value_b: state.player.ttl,
                immediate: true,
            },
            reason_code: 0,
        }
    } else if event_result.event_code == 7 {
        RuntimeIoDispatch {
            has_op: true,
            op: RuntimeIoOp {
                kind: runtime_io_kind_task_issued(),
                subject_id: previous_state.task.next_task_id,
                value_a: state.task.active_task_count,
                value_b: state.task.pending_reply_count,
                immediate: false,
            },
            reason_code: 0,
        }
    } else if event_result.event_code == 8 || event_result.event_code == 9 {
        RuntimeIoDispatch {
            has_op: true,
            op: RuntimeIoOp {
                kind: runtime_io_kind_task_finished(),
                subject_id: state.player.conn_id,
                value_a: state.task.active_task_count,
                value_b: state.task.pending_reply_count,
                immediate: false,
            },
            reason_code: 0,
        }
    } else if should_runtime_collect_gc(state) {
        RuntimeIoDispatch {
            has_op: true,
            op: RuntimeIoOp {
                kind: runtime_io_kind_gc_suggested(),
                subject_id: state.room.session_id,
                value_a: state.task.active_task_count,
                value_b: state.room.lua_ref_count,
                immediate: false,
            },
            reason_code: 0,
        }
    } else {
        RuntimeIoDispatch {
            has_op: false,
            op: empty_runtime_io_op(),
            reason_code: 7402,
        }
    }
}

def should_runtime_emit_io(dispatch: RuntimeIoDispatch) -> bool
{
    dispatch.has_op && dispatch.op.kind != runtime_io_kind_none()
}

struct RuntimeHostState {
    outbound_message_count: i64,
    db_write_count: i64,
    gc_sweep_count: i64,
    warning_count: i64,
    last_subject_id: i64,
    last_io_kind: i64,
}

struct RuntimeHostResult {
    state: RuntimeHostState,
    applied: bool,
    reason_code: i64,
}

struct RuntimeStepResult {
    engine_result: RuntimeEngineResult,
    io_dispatch: RuntimeIoDispatch,
    host_result: RuntimeHostResult,
}

struct RuntimeEvent {
    code: i64,
    arg1: i64,
    arg2: i64,
}

def runtime_event_room_join() -> i64
ensures result == 1
{
    1
}

def runtime_event_room_leave() -> i64
ensures result == 2
{
    2
}

def runtime_event_room_start() -> i64
ensures result == 3
{
    3
}

def runtime_event_room_mark_outdated() -> i64
ensures result == 4
{
    4
}

def runtime_event_player_heartbeat() -> i64
ensures result == 5
{
    5
}

def runtime_event_player_disconnect() -> i64
ensures result == 6
{
    6
}

def runtime_event_task_issue() -> i64
ensures result == 7
{
    7
}

def runtime_event_task_finish() -> i64
ensures result == 8
{
    8
}

def runtime_event_task_abort_all() -> i64
ensures result == 9
{
    9
}

def runtime_event_player_enter_game() -> i64
ensures result == 10
{
    10
}

def runtime_event_player_set_dead() -> i64
ensures result == 11
{
    11
}

def runtime_event_room_set_lua_ref() -> i64
ensures result == 12
{
    12
}

def runtime_event_player_ttl_tick() -> i64
ensures result == 13
{
    13
}

def is_runtime_event_known(event_code: i64) -> bool
{
    event_code >= 1 && event_code <= 13
}

def make_runtime_event(code: i64, arg1: i64, arg2: i64) -> RuntimeEvent
{
    RuntimeEvent {
        code: code,
        arg1: arg1,
        arg2: arg2,
    }
}

def new_runtime_host_state() -> RuntimeHostState
{
    RuntimeHostState {
        outbound_message_count: 0,
        db_write_count: 0,
        gc_sweep_count: 0,
        warning_count: 0,
        last_subject_id: 0,
        last_io_kind: runtime_io_kind_none(),
    }
}

def apply_runtime_io_dispatch_to_host(host: RuntimeHostState, dispatch: RuntimeIoDispatch) -> RuntimeHostResult
{
    if !should_runtime_emit_io(dispatch) {
        RuntimeHostResult {
            state: host,
            applied: false,
            reason_code: 7501,
        }
    } else {
        let op = dispatch.op;
        let next_outbound = if op.kind == runtime_io_kind_room_changed()
            || op.kind == runtime_io_kind_room_started()
            || op.kind == runtime_io_kind_heartbeat_ack()
            || op.kind == runtime_io_kind_player_disconnected()
        {
            host.outbound_message_count + 1
        } else {
            host.outbound_message_count
        };

        let next_db_write = if op.kind == runtime_io_kind_task_issued()
            || op.kind == runtime_io_kind_task_finished()
        {
            host.db_write_count + 1
        } else {
            host.db_write_count
        };

        let next_gc_sweep = if op.kind == runtime_io_kind_gc_suggested() {
            host.gc_sweep_count + 1
        } else {
            host.gc_sweep_count
        };

        RuntimeHostResult {
            state: RuntimeHostState {
                outbound_message_count: next_outbound,
                db_write_count: next_db_write,
                gc_sweep_count: next_gc_sweep,
                warning_count: host.warning_count,
                last_subject_id: op.subject_id,
                last_io_kind: op.kind,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_runtime_warning_tick(host: RuntimeHostState, should_warn: bool) -> RuntimeHostResult
{
    if !should_warn {
        RuntimeHostResult {
            state: host,
            applied: false,
            reason_code: 7502,
        }
    } else {
        RuntimeHostResult {
            state: RuntimeHostState {
                outbound_message_count: host.outbound_message_count,
                db_write_count: host.db_write_count,
                gc_sweep_count: host.gc_sweep_count,
                warning_count: host.warning_count + 1,
                last_subject_id: host.last_subject_id,
                last_io_kind: host.last_io_kind,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_runtime_step(
    runtime_state: RuntimeEngineState,
    host_state: RuntimeHostState,
    event_code: i64,
    arg1: i64,
    arg2: i64,
) -> RuntimeStepResult
{
    let engine_result = apply_runtime_event(runtime_state, event_code, arg1, arg2);
    let io_dispatch = build_runtime_io_dispatch(runtime_state, engine_result);
    let io_result = apply_runtime_io_dispatch_to_host(host_state, io_dispatch);
    let warning_result = apply_runtime_warning_tick(io_result.state, should_runtime_emit_heartbeat_warning(engine_result.state));
    let final_host_result = if warning_result.applied {
        warning_result
    } else {
        io_result
    };

    RuntimeStepResult {
        engine_result: engine_result,
        io_dispatch: io_dispatch,
        host_result: final_host_result,
    }
}

def should_runtime_shutdown(host_state: RuntimeHostState) -> bool
{
    host_state.warning_count >= 3
}

def apply_runtime_event_record(state: RuntimeEngineState, event: RuntimeEvent) -> RuntimeEngineResult
{
    if !is_runtime_event_known(event.code) {
        RuntimeEngineResult {
            state: state,
            applied: false,
            reason_code: 7601,
            event_code: event.code,
        }
    } else {
        apply_runtime_event(state, event.code, event.arg1, event.arg2)
    }
}

def apply_runtime_step_record(
    runtime_state: RuntimeEngineState,
    host_state: RuntimeHostState,
    event: RuntimeEvent,
) -> RuntimeStepResult
{
    if !is_runtime_event_known(event.code) {
        let unknown_engine = RuntimeEngineResult {
            state: runtime_state,
            applied: false,
            reason_code: 7601,
            event_code: event.code,
        };
        let io_dispatch = build_runtime_io_dispatch(runtime_state, unknown_engine);
        let io_result = apply_runtime_io_dispatch_to_host(host_state, io_dispatch);
        RuntimeStepResult {
            engine_result: unknown_engine,
            io_dispatch: io_dispatch,
            host_result: io_result,
        }
    } else {
        apply_runtime_step(runtime_state, host_state, event.code, event.arg1, event.arg2)
    }
}

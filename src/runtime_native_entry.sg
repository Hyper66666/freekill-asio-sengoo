extern "C" {
    pub fn sengoo_sleep_ms(ms: i64) -> i64;
    pub fn sengoo_runtime_tcp_port() -> i64;
    pub fn sengoo_runtime_udp_port() -> i64;
    pub fn sengoo_runtime_tick_sleep_ms() -> i64;
    pub fn sengoo_runtime_busy_sleep_ms() -> i64;
    pub fn sengoo_runtime_max_packet_bytes() -> i64;
    pub fn sengoo_runtime_max_error_count() -> i64;
    pub fn sengoo_runtime_max_accept_per_tick() -> i64;
    pub fn sengoo_tcp_listener_bind(port: i64) -> i64;
    pub fn sengoo_tcp_listener_accept(listener_handle: i64) -> i64;
    pub fn sengoo_tcp_connection_echo_once(conn_handle: i64, max_bytes: i64) -> i64;
    pub fn sengoo_tcp_runtime_step(listener_handle: i64, max_bytes: i64, max_accept_per_tick: i64) -> i64;
    pub fn sengoo_tcp_connection_close_all() -> i64;
    pub fn sengoo_tcp_connection_close(conn_handle: i64) -> i64;
    pub fn sengoo_tcp_listener_close(listener_handle: i64) -> i64;
    pub fn sengoo_udp_socket_bind(port: i64) -> i64;
    pub fn sengoo_udp_socket_echo_once(socket_handle: i64, max_bytes: i64) -> i64;
    pub fn sengoo_udp_socket_close(socket_handle: i64) -> i64;
}

def default_tcp_port() -> i64
ensures result >= 1 && result <= 65535
{
    sengoo_runtime_tcp_port()
}

def default_udp_port() -> i64
ensures result >= 1 && result <= 65535
{
    sengoo_runtime_udp_port()
}

def default_tick_sleep_ms() -> i64
ensures result > 0
{
    sengoo_runtime_tick_sleep_ms()
}

def default_busy_sleep_ms() -> i64
ensures result > 0
{
    sengoo_runtime_busy_sleep_ms()
}

def default_max_packet_bytes() -> i64
ensures result >= 256 && result <= 65536
{
    sengoo_runtime_max_packet_bytes()
}

def default_max_error_count() -> i64
ensures result > 0
{
    sengoo_runtime_max_error_count()
}

def default_max_accept_per_tick() -> i64
ensures result >= 1 && result <= 128
{
    sengoo_runtime_max_accept_per_tick()
}

def is_valid_port_flag(port: i64) -> i64
{
    if port >= 1 && port <= 65535 {
        1
    } else {
        0
    }
}

def normalize_positive(candidate: i64, fallback: i64) -> i64
requires fallback > 0
ensures result > 0
{
    if candidate > 0 {
        candidate
    } else {
        fallback
    }
}

def normalize_port(candidate: i64, fallback: i64) -> i64
requires is_valid_port_flag(fallback) > 0
ensures is_valid_port_flag(result) > 0
{
    if is_valid_port_flag(candidate) > 0 {
        candidate
    } else {
        fallback
    }
}

def is_tcp_disconnect_flag(rc: i64) -> i64
{
    if rc == -3 {
        1
    } else {
        0
    }
}

def main() -> i64
ensures result >= 0
{
    let tcp_port = normalize_port(default_tcp_port(), default_tcp_port());
    let udp_port = normalize_port(default_udp_port(), default_udp_port());
    let max_packet_bytes = normalize_positive(default_max_packet_bytes(), 1024);
    let tick_sleep_ms = normalize_positive(default_tick_sleep_ms(), 10);
    let busy_sleep_ms = normalize_positive(default_busy_sleep_ms(), 1);
    let max_error_count = normalize_positive(default_max_error_count(), 32);
    let max_accept_per_tick = normalize_positive(default_max_accept_per_tick(), 1);

    if is_valid_port_flag(tcp_port) == 0 {
        return 2;
    }
    if is_valid_port_flag(udp_port) == 0 {
        return 3;
    }
    let tcp_listener = sengoo_tcp_listener_bind(tcp_port);
    if tcp_listener <= 0 {
        return 101;
    }

    let udp_socket = sengoo_udp_socket_bind(udp_port);
    if udp_socket <= 0 {
        let _close_listener_rc = sengoo_tcp_listener_close(tcp_listener);
        return 102;
    }

    let running_flag = 1;
    let error_count = 0;

    while running_flag > 0 {
        let made_progress = 0;

        let tcp_step_rc = sengoo_tcp_runtime_step(tcp_listener, max_packet_bytes, max_accept_per_tick);
        if tcp_step_rc > 0 {
            made_progress = 1;
        } else if tcp_step_rc < 0 {
            error_count = error_count + 1;
        }

        let udp_io_rc = sengoo_udp_socket_echo_once(udp_socket, max_packet_bytes);
        if udp_io_rc > 0 {
            made_progress = 1;
        } else if udp_io_rc < 0 {
            error_count = error_count + 1;
        }

        if error_count > max_error_count {
            running_flag = 0;
        } else if made_progress > 0 {
            let _busy_sleep_rc = sengoo_sleep_ms(busy_sleep_ms);
        } else {
            let _tick_sleep_rc = sengoo_sleep_ms(tick_sleep_ms);
        }
    }

    let _close_all_tcp_rc = sengoo_tcp_connection_close_all();
    let _close_udp_rc = sengoo_udp_socket_close(udp_socket);
    let _close_listener_rc = sengoo_tcp_listener_close(tcp_listener);

    if error_count > max_error_count {
        201
    } else {
        0
    }
}

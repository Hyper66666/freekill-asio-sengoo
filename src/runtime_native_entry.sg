extern "C" {
    pub fn sengoo_sleep_ms(ms: i64) -> i64;
    pub fn sengoo_tcp_listener_bind(port: i64) -> i64;
    pub fn sengoo_tcp_listener_accept(listener_handle: i64) -> i64;
    pub fn sengoo_tcp_connection_echo_once(conn_handle: i64, max_bytes: i64) -> i64;
    pub fn sengoo_tcp_connection_close(conn_handle: i64) -> i64;
    pub fn sengoo_tcp_listener_close(listener_handle: i64) -> i64;
    pub fn sengoo_udp_socket_bind(port: i64) -> i64;
    pub fn sengoo_udp_socket_echo_once(socket_handle: i64, max_bytes: i64) -> i64;
    pub fn sengoo_udp_socket_close(socket_handle: i64) -> i64;
}

def default_tcp_port() -> i64
ensures result == 9527
{
    9527
}

def default_udp_port() -> i64
ensures result == 9528
{
    9528
}

def default_tick_sleep_ms() -> i64
ensures result == 20
{
    20
}

def default_busy_sleep_ms() -> i64
ensures result == 1
{
    1
}

def default_max_packet_bytes() -> i64
ensures result == 65536
{
    65536
}

def default_max_error_count() -> i64
ensures result == 200
{
    200
}

def is_valid_port_flag(port: i64) -> i64
{
    if port >= 1 && port <= 65535 {
        1
    } else {
        0
    }
}

def normalize_positive(candidate: i64, fallback: i64) -> i64
requires fallback > 0
ensures result > 0
{
    if candidate > 0 {
        candidate
    } else {
        fallback
    }
}

def normalize_port(candidate: i64, fallback: i64) -> i64
requires is_valid_port_flag(fallback) > 0
ensures is_valid_port_flag(result) > 0
{
    if is_valid_port_flag(candidate) > 0 {
        candidate
    } else {
        fallback
    }
}

def is_tcp_disconnect_flag(rc: i64) -> i64
{
    if rc == -3 {
        1
    } else {
        0
    }
}

def main() -> i64
ensures result >= 0
{
    let tcp_port = normalize_port(default_tcp_port(), default_tcp_port());
    let udp_port = normalize_port(default_udp_port(), default_udp_port());
    let max_packet_bytes = normalize_positive(default_max_packet_bytes(), 1024);
    let tick_sleep_ms = normalize_positive(default_tick_sleep_ms(), 10);
    let busy_sleep_ms = normalize_positive(default_busy_sleep_ms(), 1);
    let max_error_count = normalize_positive(default_max_error_count(), 32);

    if is_valid_port_flag(tcp_port) == 0 {
        return 2;
    }
    if is_valid_port_flag(udp_port) == 0 {
        return 3;
    }
    if tcp_port == udp_port {
        return 4;
    }

    let tcp_listener = sengoo_tcp_listener_bind(tcp_port);
    if tcp_listener <= 0 {
        return 101;
    }

    let udp_socket = sengoo_udp_socket_bind(udp_port);
    if udp_socket <= 0 {
        let _close_listener_rc = sengoo_tcp_listener_close(tcp_listener);
        return 102;
    }

    let running_flag = 1;
    let active_tcp_connection = 0;
    let error_count = 0;

    while running_flag > 0 {
        let made_progress = 0;

        if active_tcp_connection <= 0 {
            let accept_rc = sengoo_tcp_listener_accept(tcp_listener);
            if accept_rc > 0 {
                active_tcp_connection = accept_rc;
                made_progress = 1;
            } else if accept_rc < 0 {
                error_count = error_count + 1;
            }
        }

        if active_tcp_connection > 0 {
            let tcp_io_rc = sengoo_tcp_connection_echo_once(active_tcp_connection, max_packet_bytes);
            if tcp_io_rc > 0 {
                made_progress = 1;
            } else if tcp_io_rc < 0 {
                let _close_tcp_rc = sengoo_tcp_connection_close(active_tcp_connection);
                active_tcp_connection = 0;
                made_progress = 1;
                if is_tcp_disconnect_flag(tcp_io_rc) == 0 {
                    error_count = error_count + 1;
                }
            }
        }

        let udp_io_rc = sengoo_udp_socket_echo_once(udp_socket, max_packet_bytes);
        if udp_io_rc > 0 {
            made_progress = 1;
        } else if udp_io_rc < 0 {
            error_count = error_count + 1;
        }

        if error_count > max_error_count {
            running_flag = 0;
        } else if made_progress > 0 {
            let _busy_sleep_rc = sengoo_sleep_ms(busy_sleep_ms);
        } else {
            let _tick_sleep_rc = sengoo_sleep_ms(tick_sleep_ms);
        }
    }

    if active_tcp_connection > 0 {
        let _close_active_tcp_rc = sengoo_tcp_connection_close(active_tcp_connection);
    }
    let _close_udp_rc = sengoo_udp_socket_close(udp_socket);
    let _close_listener_rc = sengoo_tcp_listener_close(tcp_listener);

    if error_count > max_error_count {
        201
    } else {
        0
    }
}

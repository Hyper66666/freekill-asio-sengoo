def normalize_listen_port(port: i64, fallback: i64) -> i64
requires fallback >= 1024 && fallback <= 65535
ensures result >= 1024 && result <= 65535
{
    if port >= 1024 && port <= 65535 {
        port
    } else {
        fallback
    }
}

def next_session_id(last_id: i64) -> i64
requires last_id >= 0
ensures result >= 1 && result <= 10000000
{
    let next = last_id + 1;
    if next > 10000000 {
        1
    } else {
        next
    }
}

def classify_udp_probe(probe_code: i64) -> i64
requires probe_code >= 0
ensures result >= 0 && result <= 2
{
    if probe_code == 1 {
        1
    } else {
        if probe_code == 2 {
            2
        } else {
            0
        }
    }
}

struct ServerSocketRuntimeState {
    listen_port: i64,
    accepted_session_count: i64,
    probe_unknown_count: i64,
    probe_ok_count: i64,
    probe_fail_count: i64,
    rejected_operation_count: i64,
    last_session_id: i64,
}

struct ServerSocketTransitionResult {
    state: ServerSocketRuntimeState,
    applied: bool,
    reason_code: i64,
}

def new_server_socket_runtime_state(default_port: i64) -> ServerSocketRuntimeState
requires default_port >= 1024 && default_port <= 65535
{
    ServerSocketRuntimeState {
        listen_port: default_port,
        accepted_session_count: 0,
        probe_unknown_count: 0,
        probe_ok_count: 0,
        probe_fail_count: 0,
        rejected_operation_count: 0,
        last_session_id: 0,
    }
}

def apply_server_socket_accept(
    state: ServerSocketRuntimeState,
    requested_port: i64,
    fallback_port: i64,
    allow_accept: bool,
) -> ServerSocketTransitionResult
requires fallback_port >= 1024 && fallback_port <= 65535
{
    let next_port = normalize_listen_port(requested_port, fallback_port);
    if allow_accept {
        let next_session = next_session_id(state.last_session_id);
        ServerSocketTransitionResult {
            state: ServerSocketRuntimeState {
                listen_port: next_port,
                accepted_session_count: state.accepted_session_count + 1,
                probe_unknown_count: state.probe_unknown_count,
                probe_ok_count: state.probe_ok_count,
                probe_fail_count: state.probe_fail_count,
                rejected_operation_count: state.rejected_operation_count,
                last_session_id: next_session,
            },
            applied: true,
            reason_code: 0,
        }
    } else {
        ServerSocketTransitionResult {
            state: ServerSocketRuntimeState {
                listen_port: next_port,
                accepted_session_count: state.accepted_session_count,
                probe_unknown_count: state.probe_unknown_count,
                probe_ok_count: state.probe_ok_count,
                probe_fail_count: state.probe_fail_count,
                rejected_operation_count: state.rejected_operation_count + 1,
                last_session_id: state.last_session_id,
            },
            applied: false,
            reason_code: 9501,
        }
    }
}

def apply_server_socket_udp_probe(
    state: ServerSocketRuntimeState,
    probe_code: i64,
) -> ServerSocketTransitionResult
requires probe_code >= 0
{
    let probe_class = classify_udp_probe(probe_code);
    if probe_class == 1 {
        ServerSocketTransitionResult {
            state: ServerSocketRuntimeState {
                listen_port: state.listen_port,
                accepted_session_count: state.accepted_session_count,
                probe_unknown_count: state.probe_unknown_count,
                probe_ok_count: state.probe_ok_count + 1,
                probe_fail_count: state.probe_fail_count,
                rejected_operation_count: state.rejected_operation_count,
                last_session_id: state.last_session_id,
            },
            applied: true,
            reason_code: 0,
        }
    } else {
        if probe_class == 2 {
            ServerSocketTransitionResult {
                state: ServerSocketRuntimeState {
                    listen_port: state.listen_port,
                    accepted_session_count: state.accepted_session_count,
                    probe_unknown_count: state.probe_unknown_count,
                    probe_ok_count: state.probe_ok_count,
                    probe_fail_count: state.probe_fail_count + 1,
                    rejected_operation_count: state.rejected_operation_count + 1,
                    last_session_id: state.last_session_id,
                },
                applied: false,
                reason_code: 9502,
            }
        } else {
            ServerSocketTransitionResult {
                state: ServerSocketRuntimeState {
                    listen_port: state.listen_port,
                    accepted_session_count: state.accepted_session_count,
                    probe_unknown_count: state.probe_unknown_count + 1,
                    probe_ok_count: state.probe_ok_count,
                    probe_fail_count: state.probe_fail_count,
                    rejected_operation_count: state.rejected_operation_count + 1,
                    last_session_id: state.last_session_id,
                },
                applied: false,
                reason_code: 9503,
            }
        }
    }
}

def should_server_socket_backpressure(state: ServerSocketRuntimeState, max_session_count: i64) -> bool
requires max_session_count >= 0
{
    state.accepted_session_count >= max_session_count
}

def can_server_socket_emit_probe_notice(state: ServerSocketRuntimeState) -> bool
{
    state.probe_fail_count > 0 || state.probe_unknown_count > 0
}

def socket_protocol_tcp() -> i64
ensures result == 1
{
    1
}

def socket_protocol_udp() -> i64
ensures result == 2
{
    2
}

def max_tcp_packet_bytes() -> i64
ensures result == 65536
{
    65536
}

def max_udp_datagram_bytes() -> i64
ensures result == 65507
{
    65507
}

def next_connection_id_with_wrap(current_id: i64) -> i64
requires current_id >= 1
ensures result >= 1
{
    if current_id >= 2000000000 {
        1
    } else {
        current_id + 1
    }
}

def is_valid_packet_bytes(packet_bytes: i64, max_packet_bytes: i64) -> bool
requires packet_bytes >= 0 && max_packet_bytes > 0
{
    packet_bytes > 0 && packet_bytes <= max_packet_bytes
}

struct AsioIoContextRuntimeState {
    running: bool,
    stop_requested: bool,
    poll_count: i64,
    completion_count: i64,
    error_count: i64,
}

struct TcpIoRuntimeState {
    listen_port: i64,
    max_connection_count: i64,
    active_connection_count: i64,
    accepted_count: i64,
    closed_count: i64,
    rx_packet_count: i64,
    tx_packet_count: i64,
    rx_bytes: i64,
    tx_bytes: i64,
    rejected_count: i64,
    last_connection_id: i64,
}

struct UdpIoRuntimeState {
    listen_port: i64,
    max_peer_count: i64,
    active_peer_count: i64,
    rx_datagram_count: i64,
    tx_datagram_count: i64,
    rx_bytes: i64,
    tx_bytes: i64,
    rejected_count: i64,
}

struct SocketIoRuntimeState {
    io_context: AsioIoContextRuntimeState,
    tcp: TcpIoRuntimeState,
    udp: UdpIoRuntimeState,
    next_connection_id: i64,
}

struct SocketIoTransitionResult {
    state: SocketIoRuntimeState,
    applied: bool,
    reason_code: i64,
    connection_id: i64,
}

def new_socket_io_runtime_state(
    tcp_port: i64,
    udp_port: i64,
    max_tcp_connections: i64,
    max_udp_peers: i64,
) -> SocketIoRuntimeState
requires tcp_port >= 1024 && tcp_port <= 65535
    && udp_port >= 1024 && udp_port <= 65535
    && max_tcp_connections > 0 && max_udp_peers > 0
{
    SocketIoRuntimeState {
        io_context: AsioIoContextRuntimeState {
            running: false,
            stop_requested: false,
            poll_count: 0,
            completion_count: 0,
            error_count: 0,
        },
        tcp: TcpIoRuntimeState {
            listen_port: tcp_port,
            max_connection_count: max_tcp_connections,
            active_connection_count: 0,
            accepted_count: 0,
            closed_count: 0,
            rx_packet_count: 0,
            tx_packet_count: 0,
            rx_bytes: 0,
            tx_bytes: 0,
            rejected_count: 0,
            last_connection_id: 0,
        },
        udp: UdpIoRuntimeState {
            listen_port: udp_port,
            max_peer_count: max_udp_peers,
            active_peer_count: 0,
            rx_datagram_count: 0,
            tx_datagram_count: 0,
            rx_bytes: 0,
            tx_bytes: 0,
            rejected_count: 0,
        },
        next_connection_id: 1,
    }
}

def apply_socket_io_start(state: SocketIoRuntimeState) -> SocketIoTransitionResult
{
    if state.io_context.running {
        SocketIoTransitionResult {
            state: state,
            applied: false,
            reason_code: 9521,
            connection_id: 0,
        }
    } else {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: AsioIoContextRuntimeState {
                    running: true,
                    stop_requested: false,
                    poll_count: state.io_context.poll_count,
                    completion_count: state.io_context.completion_count,
                    error_count: state.io_context.error_count,
                },
                tcp: state.tcp,
                udp: state.udp,
                next_connection_id: state.next_connection_id,
            },
            applied: true,
            reason_code: 0,
            connection_id: 0,
        }
    }
}

def apply_socket_io_stop(state: SocketIoRuntimeState) -> SocketIoTransitionResult
{
    if !state.io_context.running {
        SocketIoTransitionResult {
            state: state,
            applied: false,
            reason_code: 9522,
            connection_id: 0,
        }
    } else {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: AsioIoContextRuntimeState {
                    running: false,
                    stop_requested: true,
                    poll_count: state.io_context.poll_count,
                    completion_count: state.io_context.completion_count,
                    error_count: state.io_context.error_count,
                },
                tcp: state.tcp,
                udp: state.udp,
                next_connection_id: state.next_connection_id,
            },
            applied: true,
            reason_code: 0,
            connection_id: 0,
        }
    }
}

def apply_socket_io_poll(
    state: SocketIoRuntimeState,
    completed_operations: i64,
    had_error: bool,
) -> SocketIoTransitionResult
requires completed_operations >= 0
{
    if !state.io_context.running {
        SocketIoTransitionResult {
            state: state,
            applied: false,
            reason_code: 9523,
            connection_id: 0,
        }
    } else {
        let next_error_count = if had_error {
            state.io_context.error_count + 1
        } else {
            state.io_context.error_count
        };
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: AsioIoContextRuntimeState {
                    running: state.io_context.running,
                    stop_requested: state.io_context.stop_requested,
                    poll_count: state.io_context.poll_count + 1,
                    completion_count: state.io_context.completion_count + completed_operations,
                    error_count: next_error_count,
                },
                tcp: state.tcp,
                udp: state.udp,
                next_connection_id: state.next_connection_id,
            },
            applied: !had_error,
            reason_code: if had_error { 9524 } else { 0 },
            connection_id: 0,
        }
    }
}

def apply_socket_io_accept_tcp(
    state: SocketIoRuntimeState,
    allow_accept: bool,
) -> SocketIoTransitionResult
{
    if !state.io_context.running {
        SocketIoTransitionResult {
            state: state,
            applied: false,
            reason_code: 9523,
            connection_id: 0,
        }
    } else if !allow_accept {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: state.io_context,
                tcp: TcpIoRuntimeState {
                    listen_port: state.tcp.listen_port,
                    max_connection_count: state.tcp.max_connection_count,
                    active_connection_count: state.tcp.active_connection_count,
                    accepted_count: state.tcp.accepted_count,
                    closed_count: state.tcp.closed_count,
                    rx_packet_count: state.tcp.rx_packet_count,
                    tx_packet_count: state.tcp.tx_packet_count,
                    rx_bytes: state.tcp.rx_bytes,
                    tx_bytes: state.tcp.tx_bytes,
                    rejected_count: state.tcp.rejected_count + 1,
                    last_connection_id: state.tcp.last_connection_id,
                },
                udp: state.udp,
                next_connection_id: state.next_connection_id,
            },
            applied: false,
            reason_code: 9525,
            connection_id: 0,
        }
    } else if state.tcp.active_connection_count >= state.tcp.max_connection_count {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: state.io_context,
                tcp: TcpIoRuntimeState {
                    listen_port: state.tcp.listen_port,
                    max_connection_count: state.tcp.max_connection_count,
                    active_connection_count: state.tcp.active_connection_count,
                    accepted_count: state.tcp.accepted_count,
                    closed_count: state.tcp.closed_count,
                    rx_packet_count: state.tcp.rx_packet_count,
                    tx_packet_count: state.tcp.tx_packet_count,
                    rx_bytes: state.tcp.rx_bytes,
                    tx_bytes: state.tcp.tx_bytes,
                    rejected_count: state.tcp.rejected_count + 1,
                    last_connection_id: state.tcp.last_connection_id,
                },
                udp: state.udp,
                next_connection_id: state.next_connection_id,
            },
            applied: false,
            reason_code: 9526,
            connection_id: 0,
        }
    } else {
        let issued_connection_id = state.next_connection_id;
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: state.io_context,
                tcp: TcpIoRuntimeState {
                    listen_port: state.tcp.listen_port,
                    max_connection_count: state.tcp.max_connection_count,
                    active_connection_count: state.tcp.active_connection_count + 1,
                    accepted_count: state.tcp.accepted_count + 1,
                    closed_count: state.tcp.closed_count,
                    rx_packet_count: state.tcp.rx_packet_count,
                    tx_packet_count: state.tcp.tx_packet_count,
                    rx_bytes: state.tcp.rx_bytes,
                    tx_bytes: state.tcp.tx_bytes,
                    rejected_count: state.tcp.rejected_count,
                    last_connection_id: issued_connection_id,
                },
                udp: state.udp,
                next_connection_id: next_connection_id_with_wrap(issued_connection_id),
            },
            applied: true,
            reason_code: 0,
            connection_id: issued_connection_id,
        }
    }
}

def apply_socket_io_close_tcp(
    state: SocketIoRuntimeState,
    had_connection: bool,
) -> SocketIoTransitionResult
{
    if !state.io_context.running {
        SocketIoTransitionResult {
            state: state,
            applied: false,
            reason_code: 9523,
            connection_id: 0,
        }
    } else if !had_connection || state.tcp.active_connection_count == 0 {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: state.io_context,
                tcp: TcpIoRuntimeState {
                    listen_port: state.tcp.listen_port,
                    max_connection_count: state.tcp.max_connection_count,
                    active_connection_count: state.tcp.active_connection_count,
                    accepted_count: state.tcp.accepted_count,
                    closed_count: state.tcp.closed_count,
                    rx_packet_count: state.tcp.rx_packet_count,
                    tx_packet_count: state.tcp.tx_packet_count,
                    rx_bytes: state.tcp.rx_bytes,
                    tx_bytes: state.tcp.tx_bytes,
                    rejected_count: state.tcp.rejected_count + 1,
                    last_connection_id: state.tcp.last_connection_id,
                },
                udp: state.udp,
                next_connection_id: state.next_connection_id,
            },
            applied: false,
            reason_code: 9527,
            connection_id: 0,
        }
    } else {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: state.io_context,
                tcp: TcpIoRuntimeState {
                    listen_port: state.tcp.listen_port,
                    max_connection_count: state.tcp.max_connection_count,
                    active_connection_count: state.tcp.active_connection_count - 1,
                    accepted_count: state.tcp.accepted_count,
                    closed_count: state.tcp.closed_count + 1,
                    rx_packet_count: state.tcp.rx_packet_count,
                    tx_packet_count: state.tcp.tx_packet_count,
                    rx_bytes: state.tcp.rx_bytes,
                    tx_bytes: state.tcp.tx_bytes,
                    rejected_count: state.tcp.rejected_count,
                    last_connection_id: state.tcp.last_connection_id,
                },
                udp: state.udp,
                next_connection_id: state.next_connection_id,
            },
            applied: true,
            reason_code: 0,
            connection_id: 0,
        }
    }
}

def apply_socket_io_receive_tcp_packet(
    state: SocketIoRuntimeState,
    connection_alive: bool,
    packet_bytes: i64,
) -> SocketIoTransitionResult
requires packet_bytes >= 0
{
    if !state.io_context.running {
        SocketIoTransitionResult {
            state: state,
            applied: false,
            reason_code: 9523,
            connection_id: 0,
        }
    } else if !connection_alive || state.tcp.active_connection_count == 0 {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: state.io_context,
                tcp: TcpIoRuntimeState {
                    listen_port: state.tcp.listen_port,
                    max_connection_count: state.tcp.max_connection_count,
                    active_connection_count: state.tcp.active_connection_count,
                    accepted_count: state.tcp.accepted_count,
                    closed_count: state.tcp.closed_count,
                    rx_packet_count: state.tcp.rx_packet_count,
                    tx_packet_count: state.tcp.tx_packet_count,
                    rx_bytes: state.tcp.rx_bytes,
                    tx_bytes: state.tcp.tx_bytes,
                    rejected_count: state.tcp.rejected_count + 1,
                    last_connection_id: state.tcp.last_connection_id,
                },
                udp: state.udp,
                next_connection_id: state.next_connection_id,
            },
            applied: false,
            reason_code: 9528,
            connection_id: 0,
        }
    } else if !is_valid_packet_bytes(packet_bytes, max_tcp_packet_bytes()) {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: state.io_context,
                tcp: TcpIoRuntimeState {
                    listen_port: state.tcp.listen_port,
                    max_connection_count: state.tcp.max_connection_count,
                    active_connection_count: state.tcp.active_connection_count,
                    accepted_count: state.tcp.accepted_count,
                    closed_count: state.tcp.closed_count,
                    rx_packet_count: state.tcp.rx_packet_count,
                    tx_packet_count: state.tcp.tx_packet_count,
                    rx_bytes: state.tcp.rx_bytes,
                    tx_bytes: state.tcp.tx_bytes,
                    rejected_count: state.tcp.rejected_count + 1,
                    last_connection_id: state.tcp.last_connection_id,
                },
                udp: state.udp,
                next_connection_id: state.next_connection_id,
            },
            applied: false,
            reason_code: 9529,
            connection_id: 0,
        }
    } else {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: state.io_context,
                tcp: TcpIoRuntimeState {
                    listen_port: state.tcp.listen_port,
                    max_connection_count: state.tcp.max_connection_count,
                    active_connection_count: state.tcp.active_connection_count,
                    accepted_count: state.tcp.accepted_count,
                    closed_count: state.tcp.closed_count,
                    rx_packet_count: state.tcp.rx_packet_count + 1,
                    tx_packet_count: state.tcp.tx_packet_count,
                    rx_bytes: state.tcp.rx_bytes + packet_bytes,
                    tx_bytes: state.tcp.tx_bytes,
                    rejected_count: state.tcp.rejected_count,
                    last_connection_id: state.tcp.last_connection_id,
                },
                udp: state.udp,
                next_connection_id: state.next_connection_id,
            },
            applied: true,
            reason_code: 0,
            connection_id: 0,
        }
    }
}

def apply_socket_io_send_tcp_packet(
    state: SocketIoRuntimeState,
    connection_alive: bool,
    packet_bytes: i64,
) -> SocketIoTransitionResult
requires packet_bytes >= 0
{
    if !state.io_context.running {
        SocketIoTransitionResult {
            state: state,
            applied: false,
            reason_code: 9523,
            connection_id: 0,
        }
    } else if !connection_alive || state.tcp.active_connection_count == 0 {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: state.io_context,
                tcp: TcpIoRuntimeState {
                    listen_port: state.tcp.listen_port,
                    max_connection_count: state.tcp.max_connection_count,
                    active_connection_count: state.tcp.active_connection_count,
                    accepted_count: state.tcp.accepted_count,
                    closed_count: state.tcp.closed_count,
                    rx_packet_count: state.tcp.rx_packet_count,
                    tx_packet_count: state.tcp.tx_packet_count,
                    rx_bytes: state.tcp.rx_bytes,
                    tx_bytes: state.tcp.tx_bytes,
                    rejected_count: state.tcp.rejected_count + 1,
                    last_connection_id: state.tcp.last_connection_id,
                },
                udp: state.udp,
                next_connection_id: state.next_connection_id,
            },
            applied: false,
            reason_code: 9530,
            connection_id: 0,
        }
    } else if !is_valid_packet_bytes(packet_bytes, max_tcp_packet_bytes()) {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: state.io_context,
                tcp: TcpIoRuntimeState {
                    listen_port: state.tcp.listen_port,
                    max_connection_count: state.tcp.max_connection_count,
                    active_connection_count: state.tcp.active_connection_count,
                    accepted_count: state.tcp.accepted_count,
                    closed_count: state.tcp.closed_count,
                    rx_packet_count: state.tcp.rx_packet_count,
                    tx_packet_count: state.tcp.tx_packet_count,
                    rx_bytes: state.tcp.rx_bytes,
                    tx_bytes: state.tcp.tx_bytes,
                    rejected_count: state.tcp.rejected_count + 1,
                    last_connection_id: state.tcp.last_connection_id,
                },
                udp: state.udp,
                next_connection_id: state.next_connection_id,
            },
            applied: false,
            reason_code: 9529,
            connection_id: 0,
        }
    } else {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: state.io_context,
                tcp: TcpIoRuntimeState {
                    listen_port: state.tcp.listen_port,
                    max_connection_count: state.tcp.max_connection_count,
                    active_connection_count: state.tcp.active_connection_count,
                    accepted_count: state.tcp.accepted_count,
                    closed_count: state.tcp.closed_count,
                    rx_packet_count: state.tcp.rx_packet_count,
                    tx_packet_count: state.tcp.tx_packet_count + 1,
                    rx_bytes: state.tcp.rx_bytes,
                    tx_bytes: state.tcp.tx_bytes + packet_bytes,
                    rejected_count: state.tcp.rejected_count,
                    last_connection_id: state.tcp.last_connection_id,
                },
                udp: state.udp,
                next_connection_id: state.next_connection_id,
            },
            applied: true,
            reason_code: 0,
            connection_id: 0,
        }
    }
}

def apply_socket_io_receive_udp_datagram(
    state: SocketIoRuntimeState,
    from_known_peer: bool,
    allow_new_peer: bool,
    datagram_bytes: i64,
) -> SocketIoTransitionResult
requires datagram_bytes >= 0
{
    if !state.io_context.running {
        SocketIoTransitionResult {
            state: state,
            applied: false,
            reason_code: 9523,
            connection_id: 0,
        }
    } else if !is_valid_packet_bytes(datagram_bytes, max_udp_datagram_bytes()) {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: state.io_context,
                tcp: state.tcp,
                udp: UdpIoRuntimeState {
                    listen_port: state.udp.listen_port,
                    max_peer_count: state.udp.max_peer_count,
                    active_peer_count: state.udp.active_peer_count,
                    rx_datagram_count: state.udp.rx_datagram_count,
                    tx_datagram_count: state.udp.tx_datagram_count,
                    rx_bytes: state.udp.rx_bytes,
                    tx_bytes: state.udp.tx_bytes,
                    rejected_count: state.udp.rejected_count + 1,
                },
                next_connection_id: state.next_connection_id,
            },
            applied: false,
            reason_code: 9531,
            connection_id: 0,
        }
    } else if from_known_peer {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: state.io_context,
                tcp: state.tcp,
                udp: UdpIoRuntimeState {
                    listen_port: state.udp.listen_port,
                    max_peer_count: state.udp.max_peer_count,
                    active_peer_count: state.udp.active_peer_count,
                    rx_datagram_count: state.udp.rx_datagram_count + 1,
                    tx_datagram_count: state.udp.tx_datagram_count,
                    rx_bytes: state.udp.rx_bytes + datagram_bytes,
                    tx_bytes: state.udp.tx_bytes,
                    rejected_count: state.udp.rejected_count,
                },
                next_connection_id: state.next_connection_id,
            },
            applied: true,
            reason_code: 0,
            connection_id: 0,
        }
    } else if allow_new_peer && state.udp.active_peer_count < state.udp.max_peer_count {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: state.io_context,
                tcp: state.tcp,
                udp: UdpIoRuntimeState {
                    listen_port: state.udp.listen_port,
                    max_peer_count: state.udp.max_peer_count,
                    active_peer_count: state.udp.active_peer_count + 1,
                    rx_datagram_count: state.udp.rx_datagram_count + 1,
                    tx_datagram_count: state.udp.tx_datagram_count,
                    rx_bytes: state.udp.rx_bytes + datagram_bytes,
                    tx_bytes: state.udp.tx_bytes,
                    rejected_count: state.udp.rejected_count,
                },
                next_connection_id: state.next_connection_id,
            },
            applied: true,
            reason_code: 0,
            connection_id: 0,
        }
    } else {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: state.io_context,
                tcp: state.tcp,
                udp: UdpIoRuntimeState {
                    listen_port: state.udp.listen_port,
                    max_peer_count: state.udp.max_peer_count,
                    active_peer_count: state.udp.active_peer_count,
                    rx_datagram_count: state.udp.rx_datagram_count,
                    tx_datagram_count: state.udp.tx_datagram_count,
                    rx_bytes: state.udp.rx_bytes,
                    tx_bytes: state.udp.tx_bytes,
                    rejected_count: state.udp.rejected_count + 1,
                },
                next_connection_id: state.next_connection_id,
            },
            applied: false,
            reason_code: 9532,
            connection_id: 0,
        }
    }
}

def apply_socket_io_send_udp_datagram(
    state: SocketIoRuntimeState,
    has_target_peer: bool,
    datagram_bytes: i64,
) -> SocketIoTransitionResult
requires datagram_bytes >= 0
{
    if !state.io_context.running {
        SocketIoTransitionResult {
            state: state,
            applied: false,
            reason_code: 9523,
            connection_id: 0,
        }
    } else if !has_target_peer || state.udp.active_peer_count == 0 {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: state.io_context,
                tcp: state.tcp,
                udp: UdpIoRuntimeState {
                    listen_port: state.udp.listen_port,
                    max_peer_count: state.udp.max_peer_count,
                    active_peer_count: state.udp.active_peer_count,
                    rx_datagram_count: state.udp.rx_datagram_count,
                    tx_datagram_count: state.udp.tx_datagram_count,
                    rx_bytes: state.udp.rx_bytes,
                    tx_bytes: state.udp.tx_bytes,
                    rejected_count: state.udp.rejected_count + 1,
                },
                next_connection_id: state.next_connection_id,
            },
            applied: false,
            reason_code: 9533,
            connection_id: 0,
        }
    } else if !is_valid_packet_bytes(datagram_bytes, max_udp_datagram_bytes()) {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: state.io_context,
                tcp: state.tcp,
                udp: UdpIoRuntimeState {
                    listen_port: state.udp.listen_port,
                    max_peer_count: state.udp.max_peer_count,
                    active_peer_count: state.udp.active_peer_count,
                    rx_datagram_count: state.udp.rx_datagram_count,
                    tx_datagram_count: state.udp.tx_datagram_count,
                    rx_bytes: state.udp.rx_bytes,
                    tx_bytes: state.udp.tx_bytes,
                    rejected_count: state.udp.rejected_count + 1,
                },
                next_connection_id: state.next_connection_id,
            },
            applied: false,
            reason_code: 9531,
            connection_id: 0,
        }
    } else {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: state.io_context,
                tcp: state.tcp,
                udp: UdpIoRuntimeState {
                    listen_port: state.udp.listen_port,
                    max_peer_count: state.udp.max_peer_count,
                    active_peer_count: state.udp.active_peer_count,
                    rx_datagram_count: state.udp.rx_datagram_count,
                    tx_datagram_count: state.udp.tx_datagram_count + 1,
                    rx_bytes: state.udp.rx_bytes,
                    tx_bytes: state.udp.tx_bytes + datagram_bytes,
                    rejected_count: state.udp.rejected_count,
                },
                next_connection_id: state.next_connection_id,
            },
            applied: true,
            reason_code: 0,
            connection_id: 0,
        }
    }
}

def apply_socket_io_release_udp_peer(
    state: SocketIoRuntimeState,
    had_peer: bool,
) -> SocketIoTransitionResult
{
    if !state.io_context.running {
        SocketIoTransitionResult {
            state: state,
            applied: false,
            reason_code: 9523,
            connection_id: 0,
        }
    } else if !had_peer || state.udp.active_peer_count == 0 {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: state.io_context,
                tcp: state.tcp,
                udp: UdpIoRuntimeState {
                    listen_port: state.udp.listen_port,
                    max_peer_count: state.udp.max_peer_count,
                    active_peer_count: state.udp.active_peer_count,
                    rx_datagram_count: state.udp.rx_datagram_count,
                    tx_datagram_count: state.udp.tx_datagram_count,
                    rx_bytes: state.udp.rx_bytes,
                    tx_bytes: state.udp.tx_bytes,
                    rejected_count: state.udp.rejected_count + 1,
                },
                next_connection_id: state.next_connection_id,
            },
            applied: false,
            reason_code: 9534,
            connection_id: 0,
        }
    } else {
        SocketIoTransitionResult {
            state: SocketIoRuntimeState {
                io_context: state.io_context,
                tcp: state.tcp,
                udp: UdpIoRuntimeState {
                    listen_port: state.udp.listen_port,
                    max_peer_count: state.udp.max_peer_count,
                    active_peer_count: state.udp.active_peer_count - 1,
                    rx_datagram_count: state.udp.rx_datagram_count,
                    tx_datagram_count: state.udp.tx_datagram_count,
                    rx_bytes: state.udp.rx_bytes,
                    tx_bytes: state.udp.tx_bytes,
                    rejected_count: state.udp.rejected_count,
                },
                next_connection_id: state.next_connection_id,
            },
            applied: true,
            reason_code: 0,
            connection_id: 0,
        }
    }
}

def should_socket_io_backpressure(state: SocketIoRuntimeState, max_total_packets: i64) -> bool
requires max_total_packets >= 0
{
    let total_packets = state.tcp.rx_packet_count
        + state.tcp.tx_packet_count
        + state.udp.rx_datagram_count
        + state.udp.tx_datagram_count;
    total_packets >= max_total_packets
}

def can_socket_io_schedule_async(state: SocketIoRuntimeState, max_total_active_endpoints: i64) -> bool
requires max_total_active_endpoints >= 0
{
    let active_total = state.tcp.active_connection_count + state.udp.active_peer_count;
    state.io_context.running && active_total < max_total_active_endpoints
}

struct TcpConnectionRuntimeState {
    connection_id: i64,
    connected: bool,
    rx_packet_count: i64,
    tx_packet_count: i64,
    rx_bytes: i64,
    tx_bytes: i64,
    rejected_operation_count: i64,
    close_reason_code: i64,
}

struct TcpConnectionTransitionResult {
    state: TcpConnectionRuntimeState,
    applied: bool,
    reason_code: i64,
}

def new_tcp_connection_runtime_state(connection_id: i64) -> TcpConnectionRuntimeState
requires connection_id >= 1
{
    TcpConnectionRuntimeState {
        connection_id: connection_id,
        connected: true,
        rx_packet_count: 0,
        tx_packet_count: 0,
        rx_bytes: 0,
        tx_bytes: 0,
        rejected_operation_count: 0,
        close_reason_code: 0,
    }
}

def apply_tcp_connection_receive(
    state: TcpConnectionRuntimeState,
    packet_bytes: i64,
) -> TcpConnectionTransitionResult
requires packet_bytes >= 0
{
    if !state.connected {
        TcpConnectionTransitionResult {
            state: TcpConnectionRuntimeState {
                connection_id: state.connection_id,
                connected: state.connected,
                rx_packet_count: state.rx_packet_count,
                tx_packet_count: state.tx_packet_count,
                rx_bytes: state.rx_bytes,
                tx_bytes: state.tx_bytes,
                rejected_operation_count: state.rejected_operation_count + 1,
                close_reason_code: state.close_reason_code,
            },
            applied: false,
            reason_code: 9541,
        }
    } else if !is_valid_packet_bytes(packet_bytes, max_tcp_packet_bytes()) {
        TcpConnectionTransitionResult {
            state: TcpConnectionRuntimeState {
                connection_id: state.connection_id,
                connected: state.connected,
                rx_packet_count: state.rx_packet_count,
                tx_packet_count: state.tx_packet_count,
                rx_bytes: state.rx_bytes,
                tx_bytes: state.tx_bytes,
                rejected_operation_count: state.rejected_operation_count + 1,
                close_reason_code: state.close_reason_code,
            },
            applied: false,
            reason_code: 9542,
        }
    } else {
        TcpConnectionTransitionResult {
            state: TcpConnectionRuntimeState {
                connection_id: state.connection_id,
                connected: state.connected,
                rx_packet_count: state.rx_packet_count + 1,
                tx_packet_count: state.tx_packet_count,
                rx_bytes: state.rx_bytes + packet_bytes,
                tx_bytes: state.tx_bytes,
                rejected_operation_count: state.rejected_operation_count,
                close_reason_code: state.close_reason_code,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_tcp_connection_send(
    state: TcpConnectionRuntimeState,
    packet_bytes: i64,
) -> TcpConnectionTransitionResult
requires packet_bytes >= 0
{
    if !state.connected {
        TcpConnectionTransitionResult {
            state: TcpConnectionRuntimeState {
                connection_id: state.connection_id,
                connected: state.connected,
                rx_packet_count: state.rx_packet_count,
                tx_packet_count: state.tx_packet_count,
                rx_bytes: state.rx_bytes,
                tx_bytes: state.tx_bytes,
                rejected_operation_count: state.rejected_operation_count + 1,
                close_reason_code: state.close_reason_code,
            },
            applied: false,
            reason_code: 9543,
        }
    } else if !is_valid_packet_bytes(packet_bytes, max_tcp_packet_bytes()) {
        TcpConnectionTransitionResult {
            state: TcpConnectionRuntimeState {
                connection_id: state.connection_id,
                connected: state.connected,
                rx_packet_count: state.rx_packet_count,
                tx_packet_count: state.tx_packet_count,
                rx_bytes: state.rx_bytes,
                tx_bytes: state.tx_bytes,
                rejected_operation_count: state.rejected_operation_count + 1,
                close_reason_code: state.close_reason_code,
            },
            applied: false,
            reason_code: 9542,
        }
    } else {
        TcpConnectionTransitionResult {
            state: TcpConnectionRuntimeState {
                connection_id: state.connection_id,
                connected: state.connected,
                rx_packet_count: state.rx_packet_count,
                tx_packet_count: state.tx_packet_count + 1,
                rx_bytes: state.rx_bytes,
                tx_bytes: state.tx_bytes + packet_bytes,
                rejected_operation_count: state.rejected_operation_count,
                close_reason_code: state.close_reason_code,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_tcp_connection_close(
    state: TcpConnectionRuntimeState,
    close_reason_code: i64,
) -> TcpConnectionTransitionResult
requires close_reason_code >= 0
{
    if !state.connected {
        TcpConnectionTransitionResult {
            state: TcpConnectionRuntimeState {
                connection_id: state.connection_id,
                connected: state.connected,
                rx_packet_count: state.rx_packet_count,
                tx_packet_count: state.tx_packet_count,
                rx_bytes: state.rx_bytes,
                tx_bytes: state.tx_bytes,
                rejected_operation_count: state.rejected_operation_count + 1,
                close_reason_code: state.close_reason_code,
            },
            applied: false,
            reason_code: 9544,
        }
    } else {
        TcpConnectionTransitionResult {
            state: TcpConnectionRuntimeState {
                connection_id: state.connection_id,
                connected: false,
                rx_packet_count: state.rx_packet_count,
                tx_packet_count: state.tx_packet_count,
                rx_bytes: state.rx_bytes,
                tx_bytes: state.tx_bytes,
                rejected_operation_count: state.rejected_operation_count,
                close_reason_code: close_reason_code,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def can_tcp_connection_exchange_more(state: TcpConnectionRuntimeState, max_packet_count: i64) -> bool
requires max_packet_count >= 0
{
    state.connected && state.rx_packet_count + state.tx_packet_count < max_packet_count
}

struct UdpPeerRuntimeState {
    peer_id: i64,
    active: bool,
    rx_datagram_count: i64,
    tx_datagram_count: i64,
    rx_bytes: i64,
    tx_bytes: i64,
    rejected_operation_count: i64,
    last_error_reason_code: i64,
}

struct UdpPeerTransitionResult {
    state: UdpPeerRuntimeState,
    applied: bool,
    reason_code: i64,
}

def new_udp_peer_runtime_state(peer_id: i64) -> UdpPeerRuntimeState
requires peer_id >= 1
{
    UdpPeerRuntimeState {
        peer_id: peer_id,
        active: true,
        rx_datagram_count: 0,
        tx_datagram_count: 0,
        rx_bytes: 0,
        tx_bytes: 0,
        rejected_operation_count: 0,
        last_error_reason_code: 0,
    }
}

def apply_udp_peer_receive(
    state: UdpPeerRuntimeState,
    datagram_bytes: i64,
) -> UdpPeerTransitionResult
requires datagram_bytes >= 0
{
    if !state.active {
        UdpPeerTransitionResult {
            state: UdpPeerRuntimeState {
                peer_id: state.peer_id,
                active: state.active,
                rx_datagram_count: state.rx_datagram_count,
                tx_datagram_count: state.tx_datagram_count,
                rx_bytes: state.rx_bytes,
                tx_bytes: state.tx_bytes,
                rejected_operation_count: state.rejected_operation_count + 1,
                last_error_reason_code: 9551,
            },
            applied: false,
            reason_code: 9551,
        }
    } else if !is_valid_packet_bytes(datagram_bytes, max_udp_datagram_bytes()) {
        UdpPeerTransitionResult {
            state: UdpPeerRuntimeState {
                peer_id: state.peer_id,
                active: state.active,
                rx_datagram_count: state.rx_datagram_count,
                tx_datagram_count: state.tx_datagram_count,
                rx_bytes: state.rx_bytes,
                tx_bytes: state.tx_bytes,
                rejected_operation_count: state.rejected_operation_count + 1,
                last_error_reason_code: 9552,
            },
            applied: false,
            reason_code: 9552,
        }
    } else {
        UdpPeerTransitionResult {
            state: UdpPeerRuntimeState {
                peer_id: state.peer_id,
                active: state.active,
                rx_datagram_count: state.rx_datagram_count + 1,
                tx_datagram_count: state.tx_datagram_count,
                rx_bytes: state.rx_bytes + datagram_bytes,
                tx_bytes: state.tx_bytes,
                rejected_operation_count: state.rejected_operation_count,
                last_error_reason_code: state.last_error_reason_code,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_udp_peer_send(
    state: UdpPeerRuntimeState,
    datagram_bytes: i64,
) -> UdpPeerTransitionResult
requires datagram_bytes >= 0
{
    if !state.active {
        UdpPeerTransitionResult {
            state: UdpPeerRuntimeState {
                peer_id: state.peer_id,
                active: state.active,
                rx_datagram_count: state.rx_datagram_count,
                tx_datagram_count: state.tx_datagram_count,
                rx_bytes: state.rx_bytes,
                tx_bytes: state.tx_bytes,
                rejected_operation_count: state.rejected_operation_count + 1,
                last_error_reason_code: 9553,
            },
            applied: false,
            reason_code: 9553,
        }
    } else if !is_valid_packet_bytes(datagram_bytes, max_udp_datagram_bytes()) {
        UdpPeerTransitionResult {
            state: UdpPeerRuntimeState {
                peer_id: state.peer_id,
                active: state.active,
                rx_datagram_count: state.rx_datagram_count,
                tx_datagram_count: state.tx_datagram_count,
                rx_bytes: state.rx_bytes,
                tx_bytes: state.tx_bytes,
                rejected_operation_count: state.rejected_operation_count + 1,
                last_error_reason_code: 9552,
            },
            applied: false,
            reason_code: 9552,
        }
    } else {
        UdpPeerTransitionResult {
            state: UdpPeerRuntimeState {
                peer_id: state.peer_id,
                active: state.active,
                rx_datagram_count: state.rx_datagram_count,
                tx_datagram_count: state.tx_datagram_count + 1,
                rx_bytes: state.rx_bytes,
                tx_bytes: state.tx_bytes + datagram_bytes,
                rejected_operation_count: state.rejected_operation_count,
                last_error_reason_code: state.last_error_reason_code,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def apply_udp_peer_release(
    state: UdpPeerRuntimeState,
    reason_code: i64,
) -> UdpPeerTransitionResult
requires reason_code >= 0
{
    if !state.active {
        UdpPeerTransitionResult {
            state: UdpPeerRuntimeState {
                peer_id: state.peer_id,
                active: state.active,
                rx_datagram_count: state.rx_datagram_count,
                tx_datagram_count: state.tx_datagram_count,
                rx_bytes: state.rx_bytes,
                tx_bytes: state.tx_bytes,
                rejected_operation_count: state.rejected_operation_count + 1,
                last_error_reason_code: state.last_error_reason_code,
            },
            applied: false,
            reason_code: 9554,
        }
    } else {
        UdpPeerTransitionResult {
            state: UdpPeerRuntimeState {
                peer_id: state.peer_id,
                active: false,
                rx_datagram_count: state.rx_datagram_count,
                tx_datagram_count: state.tx_datagram_count,
                rx_bytes: state.rx_bytes,
                tx_bytes: state.tx_bytes,
                rejected_operation_count: state.rejected_operation_count,
                last_error_reason_code: reason_code,
            },
            applied: true,
            reason_code: 0,
        }
    }
}

def can_udp_peer_exchange_more(state: UdpPeerRuntimeState, max_datagram_count: i64) -> bool
requires max_datagram_count >= 0
{
    state.active && state.rx_datagram_count + state.tx_datagram_count < max_datagram_count
}
